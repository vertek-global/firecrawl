{"version":3,"file":"index-worker.js","sourceRoot":"","sources":["../../../../src/services/indexing/index-worker.ts"],"names":[],"mappings":"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","sourcesContent":["import \"dotenv/config\";\nimport \"../sentry\";\nimport * as Sentry from \"@sentry/node\";\nimport { Job, Queue, Worker } from \"bullmq\";\nimport { logger as _logger, logger } from \"../../lib/logger\";\nimport {\n  redisConnection,\n  getBillingQueue,\n} from \"../queue-service\";\nimport { processBillingBatch, queueBillingOperation, startBillingBatchProcessing } from \"../billing/batch_billing\";\nimport systemMonitor from \"../system-monitor\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { processIndexInsertJobs } from \"..\";\nimport { processWebhookInsertJobs } from \"../webhook\";\n\nconst workerLockDuration = Number(process.env.WORKER_LOCK_DURATION) || 60000;\nconst workerStalledCheckInterval =\n  Number(process.env.WORKER_STALLED_CHECK_INTERVAL) || 30000;\nconst jobLockExtendInterval =\n  Number(process.env.JOB_LOCK_EXTEND_INTERVAL) || 15000;\nconst jobLockExtensionTime =\n  Number(process.env.JOB_LOCK_EXTENSION_TIME) || 60000;\n\nconst cantAcceptConnectionInterval =\n  Number(process.env.CANT_ACCEPT_CONNECTION_INTERVAL) || 2000;\nconst connectionMonitorInterval =\n  Number(process.env.CONNECTION_MONITOR_INTERVAL) || 10;\nconst gotJobInterval = Number(process.env.CONNECTION_MONITOR_INTERVAL) || 20;\n\nconst runningJobs: Set<string> = new Set();\n\n// Create a processor for billing jobs\nconst processBillingJobInternal = async (token: string, job: Job) => {\n  if (!job.id) {\n    throw new Error(\"Job has no ID\");\n  }\n\n  const logger = _logger.child({\n    module: \"billing-worker\",\n    method: \"processBillingJobInternal\",\n    jobId: job.id,\n  });\n\n  const extendLockInterval = setInterval(async () => {\n    logger.info(`ðŸ”„ Worker extending lock on billing job ${job.id}`);\n    await job.extendLock(token, jobLockExtensionTime);\n  }, jobLockExtendInterval);\n\n  let err = null;\n  try {\n    // Check job type - it could be either a batch processing trigger or an individual billing operation\n    if (job.name === \"process-batch\") {\n      // Process the entire batch\n      logger.info(\"Received batch process trigger job\");\n      await processBillingBatch();\n    } else if (job.name === \"bill_team\") {\n      // This is an individual billing operation that should be queued for batch processing\n      const { team_id, subscription_id, credits, is_extract } = job.data;\n      \n      logger.info(`Adding team ${team_id} billing operation to batch queue`, {\n        credits,\n        is_extract,\n        originating_job_id: job.data.originating_job_id,\n      });\n      \n      // Add to the REDIS batch queue \n      await queueBillingOperation(team_id, subscription_id, credits, is_extract);\n    } else {\n      logger.warn(`Unknown billing job type: ${job.name}`);\n    }\n    \n    await job.moveToCompleted({ success: true }, token, false);\n  } catch (error) {\n    logger.error(\"Error processing billing job\", { error });\n    Sentry.captureException(error);\n    err = error;\n    await job.moveToFailed(error, token, false);\n  } finally {\n    clearInterval(extendLockInterval);\n  }\n\n  return err;\n};\n\nlet isShuttingDown = false;\n\nprocess.on(\"SIGINT\", () => {\n  logger.info(\"Received SIGTERM. Shutting down gracefully...\");\n  isShuttingDown = true;\n});\n\nprocess.on(\"SIGTERM\", () => {\n  logger.info(\"Received SIGTERM. Shutting down gracefully...\");\n  isShuttingDown = true;\n});\n\nlet cantAcceptConnectionCount = 0;\n\n// Generic worker function that can process different job types\nconst workerFun = async (queue: Queue, jobProcessor: (token: string, job: Job) => Promise<any>) => {\n  const logger = _logger.child({ module: \"index-worker\", method: \"workerFun\" });\n\n  const worker = new Worker(queue.name, null, {\n    connection: redisConnection,\n    lockDuration: workerLockDuration,\n    stalledInterval: workerStalledCheckInterval,\n    maxStalledCount: 10,\n  });\n\n  worker.startStalledCheckTimer();\n\n  const monitor = await systemMonitor;\n\n  while (true) {\n    if (isShuttingDown) {\n      logger.info(\"No longer accepting new jobs. SIGINT\");\n      break;\n    }\n\n    const token = uuidv4();\n    const canAcceptConnection = await monitor.acceptConnection();\n\n    if (!canAcceptConnection) {\n      console.log(\"Can't accept connection due to RAM/CPU load\");\n      logger.info(\"Can't accept connection due to RAM/CPU load\");\n      cantAcceptConnectionCount++;\n\n      if (cantAcceptConnectionCount >= 25) {\n        logger.error(\"WORKER STALLED\", {\n          cpuUsage: await monitor.checkCpuUsage(),\n          memoryUsage: await monitor.checkMemoryUsage(),\n        });\n      }\n\n      await new Promise((resolve) =>\n        setTimeout(resolve, cantAcceptConnectionInterval),\n      );\n      continue;\n    } else {\n      cantAcceptConnectionCount = 0;\n    }\n\n    const job = await worker.getNextJob(token);\n    if (job) {\n      if (job.id) {\n        runningJobs.add(job.id);\n      }\n\n      if (job.data && job.data.sentry && Sentry.isInitialized()) {\n        Sentry.continueTrace(\n          {\n            sentryTrace: job.data.sentry.trace,\n            baggage: job.data.sentry.baggage,\n          },\n          () => {\n            Sentry.startSpan(\n              {\n                name: \"Index job\",\n                attributes: {\n                  job: job.id,\n                  worker: process.env.FLY_MACHINE_ID ?? worker.id,\n                },\n              },\n              async () => {\n                await jobProcessor(token, job);\n              },\n            );\n          },\n        );\n      } else {\n        await jobProcessor(token, job);\n      }\n\n      if (job.id) {\n        runningJobs.delete(job.id);\n      }\n\n      await new Promise((resolve) => setTimeout(resolve, gotJobInterval));\n    } else {\n      await new Promise((resolve) =>\n        setTimeout(resolve, connectionMonitorInterval),\n      );\n    }\n  }\n\n  logger.info(\"Worker loop ended. Waiting for running jobs to finish...\");\n  while (runningJobs.size > 0) {\n    await new Promise((resolve) => setTimeout(resolve, 500));\n  }\n  logger.info(\"All jobs finished. Worker exiting!\");\n  process.exit(0);\n};\n\nconst INDEX_INSERT_INTERVAL = 15000;\nconst WEBHOOK_INSERT_INTERVAL = 15000;\n\n// Start the workers\n(async () => {\n  // Start billing worker and batch processing\n  startBillingBatchProcessing();\n  const billingWorkerPromise = workerFun(getBillingQueue(), processBillingJobInternal);\n\n  const indexInserterInterval = setInterval(async () => {\n    if (isShuttingDown) {\n      return;\n    }\n    \n    await processIndexInsertJobs();\n  }, INDEX_INSERT_INTERVAL);\n\n  const webhookInserterInterval = setInterval(async () => {\n    if (isShuttingDown) {\n      return;\n    }\n    await processWebhookInsertJobs();\n  }, WEBHOOK_INSERT_INTERVAL);\n\n  // Wait for all workers to complete (which should only happen on shutdown)\n  await Promise.all([billingWorkerPromise]);\n\n  clearInterval(indexInserterInterval);\n  clearInterval(webhookInserterInterval);\n})();\n"]}