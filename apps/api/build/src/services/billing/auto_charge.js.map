{"version":3,"file":"auto_charge.js","sourceRoot":"","sources":["../../../../src/services/billing/auto_charge.ts"],"names":[],"mappings":"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","sourcesContent":["// Import necessary dependencies and types\nimport { AuthCreditUsageChunk } from \"../../controllers/v1/types\";\nimport { clearACUC, clearACUCTeam, getACUC } from \"../../controllers/auth\";\nimport { redlock } from \"../redlock\";\nimport { supabase_rr_service, supabase_service } from \"../supabase\";\nimport { createPaymentIntent } from \"./stripe\";\nimport { issueCredits } from \"./issue_credits\";\nimport { sendNotification, sendNotificationWithCustomDays } from \"../notification/email_notification\";\nimport { NotificationType } from \"../../types\";\nimport { deleteKey, getValue, setValue } from \"../redis\";\nimport { redisRateLimitClient } from \"../rate-limiter\";\nimport { sendSlackWebhook } from \"../alerts/slack\";\nimport { logger as _logger } from \"../../lib/logger\";\n\n// Define the number of credits to be added during auto-recharge\nconst AUTO_RECHARGE_CREDITS = 1000;\nconst AUTO_RECHARGE_COOLDOWN = 600; // 10 minutes in seconds\nconst MAX_CHARGES_PER_HOUR = 5; // Maximum number of auto-charges per hour\nconst HOURLY_COUNTER_EXPIRY = 3600; // 1 hour in seconds\n\n/**\n * Attempt to automatically charge a user's account when their credit balance falls below a threshold\n * @param chunk The user's current usage data\n * @param autoRechargeThreshold The credit threshold that triggers auto-recharge\n */\nexport async function autoCharge(\n  chunk: AuthCreditUsageChunk,\n  autoRechargeThreshold: number,\n): Promise<{\n  success: boolean;\n  message: string;\n  remainingCredits: number;\n  chunk: AuthCreditUsageChunk;\n}> {\n  const logger = _logger.child({\n    module: \"auto_charge\",\n    method: \"autoCharge\",\n    team_id: chunk.team_id,\n    teamId: chunk.team_id,\n  });\n\n  const resource = `auto-recharge:${chunk.team_id}`;\n  const cooldownKey = `auto-recharge-cooldown:${chunk.team_id}`;\n  const hourlyCounterKey = `auto-recharge-hourly:${chunk.team_id}`;\n\n  if (chunk.team_id === \"285bb597-6eaf-4b96-801c-51461fc3c543\" || chunk.team_id === \"dec639a0-98ca-4995-95b5-48ac1ffab5b7\") {\n    return {\n      success: false,\n      message: \"Auto-recharge failed: blocked team\",\n      remainingCredits: chunk.remaining_credits,\n      chunk,\n    };\n  }\n\n  try {\n    // Check hourly rate limit first without incrementing\n    const currentCharges = await redisRateLimitClient.get(hourlyCounterKey);\n    const hourlyCharges = currentCharges ? parseInt(currentCharges) : 0;\n\n    if (hourlyCharges >= MAX_CHARGES_PER_HOUR) {\n      logger.warn(\n        `Auto-recharge exceeded hourly limit of ${MAX_CHARGES_PER_HOUR}`,\n      );\n      return {\n        success: false,\n        message: \"Auto-recharge hourly limit exceeded\",\n        remainingCredits: chunk.remaining_credits,\n        chunk,\n      };\n    }\n\n    // Check cooldown period\n    const cooldownValue = await getValue(cooldownKey);\n    if (cooldownValue) {\n      logger.info(\n        `Auto-recharge is in cooldown period`,\n      );\n      return {\n        success: false,\n        message: \"Auto-recharge is in cooldown period\",\n        remainingCredits: chunk.remaining_credits,\n        chunk,\n      };\n    }\n\n    // Use a distributed lock to prevent concurrent auto-charge attempts\n    return await redlock.using(\n      [resource],\n      5000,\n      async (\n        signal,\n      ): Promise<{\n        success: boolean;\n        message: string;\n        remainingCredits: number;\n        chunk: AuthCreditUsageChunk;\n      }> => {\n        // Recheck all conditions inside the lock to prevent race conditions\n        const updatedChunk = await getACUC(chunk.api_key, false, false);\n\n        // Recheck cooldown\n        const cooldownValue = await getValue(cooldownKey);\n        if (cooldownValue) {\n          logger.info(\n            `Auto-recharge is in cooldown period`,\n          );\n          return {\n            success: false,\n            message: \"Auto-recharge is in cooldown period\",\n            remainingCredits: chunk.remaining_credits,\n            chunk,\n          };\n        }\n\n        // Recheck hourly limit inside lock\n        const currentCharges = await redisRateLimitClient.get(hourlyCounterKey);\n        const hourlyCharges = currentCharges ? parseInt(currentCharges) : 0;\n        if (hourlyCharges >= MAX_CHARGES_PER_HOUR) {\n          return {\n            success: false,\n            message: \"Auto-recharge hourly limit exceeded\",\n            remainingCredits: chunk.remaining_credits,\n            chunk,\n          };\n        }\n\n        if (\n          updatedChunk &&\n          updatedChunk.remaining_credits < autoRechargeThreshold\n        ) {\n          if (chunk.sub_user_id) {\n            // Fetch the customer's Stripe information\n            const { data: customer, error: customersError } =\n              await supabase_rr_service\n                .from(\"customers\")\n                .select(\"id, stripe_customer_id\")\n                .eq(\"id\", chunk.sub_user_id)\n                .single();\n\n            if (customersError) {\n              logger.error(`Error fetching customer data`, { error: customersError });\n              return {\n                success: false,\n                message: \"Error fetching customer data\",\n                remainingCredits: chunk.remaining_credits,\n                chunk,\n              };\n            }\n\n            if (customer && customer.stripe_customer_id) {\n              let issueCreditsSuccess = false;\n\n              // Set cooldown BEFORE attempting payment\n              await setValue(cooldownKey, \"true\", AUTO_RECHARGE_COOLDOWN);\n\n              // Attempt to create a payment intent\n              const paymentStatus = await createPaymentIntent(\n                chunk.team_id,\n                customer.stripe_customer_id,\n              );\n\n              // If payment is successful or requires further action, issue credits\n              if (\n                paymentStatus.return_status === \"succeeded\" ||\n                paymentStatus.return_status === \"requires_action\"\n              ) {\n                issueCreditsSuccess = await issueCredits(\n                  chunk.team_id,\n                  AUTO_RECHARGE_CREDITS,\n                );\n              }\n\n              // Record the auto-recharge transaction\n              await supabase_service.from(\"auto_recharge_transactions\").insert({\n                team_id: chunk.team_id,\n                initial_payment_status: paymentStatus.return_status,\n                credits_issued: issueCreditsSuccess ? AUTO_RECHARGE_CREDITS : 0,\n                stripe_charge_id: paymentStatus.charge_id,\n              });\n\n              // Send a notification if credits were successfully issued\n              if (issueCreditsSuccess) {\n                // Increment hourly counter and set expiry if it doesn't exist\n                await redisRateLimitClient.incr(hourlyCounterKey);\n                await redisRateLimitClient.expire(\n                  hourlyCounterKey,\n                  HOURLY_COUNTER_EXPIRY,\n                  \"NX\",\n                );\n\n                try {\n                  // Check for frequent auto-recharges in the past week\n                  const weeklyAutoRechargeKey = `auto-recharge-weekly:${chunk.team_id}`;\n                  const weeklyRecharges = await redisRateLimitClient.incr(weeklyAutoRechargeKey);\n                  // Set expiry for 7 days if not already set\n                await redisRateLimitClient.expire(weeklyAutoRechargeKey, 7 * 24 * 60 * 60);\n\n                // If this is the second auto-recharge in a week, send notification\n                if (weeklyRecharges >= 2) {\n                  await sendNotificationWithCustomDays(\n                    chunk.team_id,\n                    NotificationType.AUTO_RECHARGE_FREQUENT,\n                    7, // Send at most once per week\n                    false\n                  );\n                }\n                } catch (error) {\n                  logger.error(`Error sending frequent auto-recharge notification`, { error });\n                }\n\n                await sendNotification(\n                  chunk.team_id,\n                  NotificationType.AUTO_RECHARGE_SUCCESS,\n                  chunk.sub_current_period_start,\n                  chunk.sub_current_period_end,\n                  chunk,\n                  true,\n                );\n\n                // Reset ACUC cache to reflect the new credit balance\n                await clearACUC(chunk.api_key);\n                await clearACUCTeam(chunk.team_id);\n\n                logger.info(`Auto-recharge successful`, {\n                  credits: AUTO_RECHARGE_CREDITS,\n                  paymentStatus: paymentStatus.return_status,\n                });\n\n                if (process.env.SLACK_ADMIN_WEBHOOK_URL) {\n                  const webhookCooldownKey = `webhook_cooldown_${chunk.team_id}`;\n                  const isInCooldown = await getValue(webhookCooldownKey);\n\n                  if (!isInCooldown) {\n                    sendSlackWebhook(\n                      `Auto-recharge: Team ${chunk.team_id}. ${AUTO_RECHARGE_CREDITS} credits added. Payment status: ${paymentStatus.return_status}.`,\n                      false,\n                      process.env.SLACK_ADMIN_WEBHOOK_URL,\n                    ).catch((error) => {\n                      logger.debug(\n                        `Error sending slack notification: ${error}`,\n                      );\n                    });\n\n                    // Set cooldown for 1 hour\n                    await setValue(webhookCooldownKey, \"true\", 60 * 60);\n                  }\n                }\n                return {\n                  success: true,\n                  message: \"Auto-recharge successful\",\n                  remainingCredits:\n                    chunk.remaining_credits + AUTO_RECHARGE_CREDITS,\n                  chunk: {\n                    ...chunk,\n                    remaining_credits:\n                      chunk.remaining_credits + AUTO_RECHARGE_CREDITS,\n                  },\n                };\n              } else {\n                logger.error(\"No Stripe customer ID found for user\");\n                return {\n                  success: false,\n                  message: \"No Stripe customer ID found for user\",\n                  remainingCredits: chunk.remaining_credits,\n                  chunk,\n                };\n              }\n            } else {\n              logger.error(\"No Stripe customer ID found for user\");\n              return {\n                success: false,\n                message: \"No Stripe customer ID found for user\",\n                remainingCredits: chunk.remaining_credits,\n                chunk,\n              };\n            }\n          } else {\n            logger.error(\"No sub_user_id found in chunk\");\n            return {\n              success: false,\n              message: \"No sub_user_id found in chunk\",\n              remainingCredits: chunk.remaining_credits,\n              chunk,\n            };\n          }\n        }\n        return {\n          success: false,\n          message: \"No need to auto-recharge\",\n          remainingCredits: chunk.remaining_credits,\n          chunk,\n        };\n      },\n    );\n  } catch (error) {\n    logger.error(`Failed to acquire lock for auto-recharge`, { error });\n    return {\n      success: false,\n      message: \"Failed to acquire lock for auto-recharge\",\n      remainingCredits: chunk.remaining_credits,\n      chunk,\n    };\n  }\n}\n"]}