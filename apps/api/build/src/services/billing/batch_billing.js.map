{"version":3,"file":"batch_billing.js","sourceRoot":"","sources":["../../../../src/services/billing/batch_billing.ts"],"names":[],"mappings":"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","sourcesContent":["import { logger } from \"../../lib/logger\";\nimport { redisConnection } from \"../queue-service\";\nimport { supabase_service } from \"../supabase\";\nimport * as Sentry from \"@sentry/node\";\nimport { Queue } from \"bullmq\";\nimport { withAuth } from \"../../lib/withAuth\";\nimport { getACUC, setCachedACUC, setCachedACUCTeam } from \"../../controllers/auth\";\n\n// Configuration constants\nconst BATCH_KEY = \"billing_batch\";\nconst BATCH_LOCK_KEY = \"billing_batch_lock\";\nconst BATCH_SIZE = 100; // Batch size for processing\nconst BATCH_TIMEOUT = 15000; // 15 seconds processing interval\nconst LOCK_TIMEOUT = 30000; // 30 seconds lock timeout\n\n// Define interfaces for billing operations\ninterface BillingOperation {\n  team_id: string;\n  subscription_id: string | null;\n  credits: number;\n  is_extract: boolean;\n  timestamp: string;\n}\n\n// Grouped billing operations for batch processing\ninterface GroupedBillingOperation {\n  team_id: string;\n  subscription_id: string | null;\n  total_credits: number;\n  is_extract: boolean;\n  operations: BillingOperation[];\n}\n\n// Function to acquire a lock for batch processing\nasync function acquireLock(): Promise<boolean> {\n  const redis = redisConnection;\n  // Set lock with NX (only if it doesn't exist) and PX (millisecond expiry)\n  const result = await redis.set(BATCH_LOCK_KEY, \"1\", \"PX\", LOCK_TIMEOUT, \"NX\");\n  const acquired = result === \"OK\";\n  if (acquired) {\n    logger.info(\"🔒 Acquired billing batch processing lock\");\n  }\n  return acquired;\n}\n\n// Function to release the lock\nasync function releaseLock() {\n  const redis = redisConnection;\n  await redis.del(BATCH_LOCK_KEY);\n  logger.info(\"🔓 Released billing batch processing lock\");\n}\n\n// Main function to process the billing batch\nexport async function processBillingBatch() {\n  const redis = redisConnection;\n  \n  // Try to acquire lock\n  if (!(await acquireLock())) {\n    return;\n  }\n  \n  try {\n    // Get all operations from Redis list\n    const operations: BillingOperation[] = [];\n    while (operations.length < BATCH_SIZE) {\n      const op = await redis.lpop(BATCH_KEY);\n      if (!op) break;\n      operations.push(JSON.parse(op));\n    }\n    \n    if (operations.length === 0) {\n      logger.info(\"No billing operations to process in batch\");\n      return;\n    }\n    \n    logger.info(`📦 Processing batch of ${operations.length} billing operations`);\n    \n    // Group operations by team_id and subscription_id\n    const groupedOperations = new Map<string, GroupedBillingOperation>();\n    \n    for (const op of operations) {\n      const key = `${op.team_id}:${op.subscription_id ?? 'null'}:${op.is_extract}`;\n      \n      if (!groupedOperations.has(key)) {\n        groupedOperations.set(key, {\n          team_id: op.team_id,\n          subscription_id: op.subscription_id,\n          total_credits: 0,\n          is_extract: op.is_extract,\n          operations: []\n        });\n      }\n      \n      const group = groupedOperations.get(key)!;\n      group.total_credits += op.credits;\n      group.operations.push(op);\n    }\n    \n    // Process each group of operations\n    for (const [key, group] of groupedOperations.entries()) {\n      logger.info(`🔄 Billing team ${group.team_id} for ${group.total_credits} credits`, {\n        team_id: group.team_id,\n        subscription_id: group.subscription_id,\n        total_credits: group.total_credits,\n        operation_count: group.operations.length,\n        is_extract: group.is_extract\n      });\n      \n      // Skip billing for preview teams\n      if (group.team_id === \"preview\" || group.team_id.startsWith(\"preview_\")) {\n        logger.info(`Skipping billing for preview team ${group.team_id}`);\n        continue;\n      }\n      \n      try {\n        // Execute the actual billing\n        await withAuth(supaBillTeam, { success: true, message: \"No DB, bypassed.\" })(\n          group.team_id,\n          group.subscription_id,\n          group.total_credits,\n          logger,\n          group.is_extract\n        );\n        \n        logger.info(`✅ Successfully billed team ${group.team_id} for ${group.total_credits} ${group.is_extract ? 'tokens' : 'credits'}`);\n      } catch (error) {\n        logger.error(`❌ Failed to bill team ${group.team_id}`, { error, group });\n        Sentry.captureException(error, {\n          data: {\n            operation: \"batch_billing\",\n            team_id: group.team_id,\n            credits: group.total_credits\n          }\n        });\n      }\n    }\n    \n    logger.info(\"✅ Billing batch processing completed successfully\");\n  } catch (error) {\n    logger.error(\"Error processing billing batch\", { error });\n    Sentry.captureException(error, {\n      data: {\n        operation: \"batch_billing_process\"\n      }\n    });\n  } finally {\n    await releaseLock();\n  }\n}\n\n// Start periodic batch processing\nlet batchInterval: NodeJS.Timeout | null = null;\n\nexport function startBillingBatchProcessing() {\n  if (batchInterval) return;\n  \n  logger.info(\"🔄 Starting periodic billing batch processing\");\n  batchInterval = setInterval(async () => {\n    const queueLength = await redisConnection.llen(BATCH_KEY);\n    logger.info(`Checking billing batch queue (${queueLength} items pending)`);\n    await processBillingBatch();\n  }, BATCH_TIMEOUT);\n  \n  // Unref to not keep process alive\n  batchInterval.unref();\n}\n\n// Add a billing operation to the queue\nexport async function queueBillingOperation(\n  team_id: string,\n  subscription_id: string | null | undefined,\n  credits: number,\n  is_extract: boolean = false\n) {\n  // Skip queuing for preview teams\n  if (team_id === \"preview\" || team_id.startsWith(\"preview_\")) {\n    logger.info(`Skipping billing queue for preview team ${team_id}`);\n    return { success: true, message: \"Preview team, no credits used\" };\n  }\n  \n  logger.info(`Queueing billing operation for team ${team_id}`, {\n    team_id,\n    subscription_id,\n    credits,\n    is_extract\n  });\n  \n  try {\n    const operation: BillingOperation = {\n      team_id,\n      subscription_id: subscription_id ?? null,\n      credits,\n      is_extract,\n      timestamp: new Date().toISOString()\n    };\n    \n    // Add operation to Redis list\n    const redis = redisConnection;\n    await redis.rpush(BATCH_KEY, JSON.stringify(operation));\n    const queueLength = await redis.llen(BATCH_KEY);\n    logger.info(`📥 Added billing operation to queue (${queueLength} total pending)`, {\n      team_id,\n      credits\n    });\n    \n    // Start batch processing if not already started\n    startBillingBatchProcessing();\n    \n    // If we have enough items, trigger immediate processing\n    if (queueLength >= BATCH_SIZE) {\n      logger.info(\"🔄 Billing queue reached batch size, triggering immediate processing\");\n      await processBillingBatch();\n    }\n    // TODO is there a better way to do this?\n    \n    // Update cached credits used immediately to provide accurate feedback to users\n    // This is optimistic - actual billing happens in batch\n    // Should we add this?\n    // I guess batch is fast enough that it's fine\n\n\n    // if (process.env.USE_DB_AUTHENTICATION === \"true\") {\n    //   (async () => {\n    //     // Get API keys for this team to update in cache\n    //     const { data } = await supabase_service\n    //       .from(\"api_keys\")\n    //       .select(\"key\")\n    //       .eq(\"team_id\", team_id);\n          \n    //     for (const apiKey of (data ?? []).map(x => x.key)) {\n    //       await setCachedACUC(apiKey, (acuc) =>\n    //         acuc\n    //           ? {\n    //               ...acuc,\n    //               credits_used: acuc.credits_used + credits,\n    //               adjusted_credits_used: acuc.adjusted_credits_used + credits,\n    //               remaining_credits: acuc.remaining_credits - credits,\n    //             }\n    //           : null,\n    //       );\n    //     }\n    //   })().catch(error => {\n    //     logger.error(\"Failed to update cached credits\", { error, team_id });\n    //   });\n    // }\n    \n    return { success: true };\n  } catch (error) {\n    logger.error(\"Error queueing billing operation\", { error, team_id });\n    Sentry.captureException(error, {\n      data: {\n        operation: \"queue_billing\",\n        team_id,\n        credits\n      }\n    });\n    return { success: false, error };\n  }\n}\n\n// Modified version of the billing function for batch operations\nasync function supaBillTeam(\n  team_id: string,\n  subscription_id: string | null | undefined,\n  credits: number,\n  __logger?: any,\n  is_extract: boolean = false,\n) {\n  const _logger = (__logger ?? logger).child({\n    module: \"credit_billing\",\n    method: \"supaBillTeam\",\n    teamId: team_id,\n    subscriptionId: subscription_id,\n    credits,\n  });\n\n  if (team_id === \"preview\" || team_id.startsWith(\"preview_\")) {\n    return { success: true, message: \"Preview team, no credits used\" };\n  }\n  \n  _logger.info(`Batch billing team ${team_id} for ${credits} credits`);\n\n  // Perform the actual database operation\n  const { data, error } = await supabase_service.rpc(\"bill_team_4_tally\", {\n    _team_id: team_id,\n    sub_id: subscription_id ?? null,\n    fetch_subscription: subscription_id === undefined,\n    credits,\n    is_extract_param: is_extract,\n  });\n\n  if (error) {\n    Sentry.captureException(error);\n    _logger.error(\"Failed to bill team.\", { error });\n    return { success: false, error };\n  }\n\n  // Update cached ACUC to reflect the new credit usage\n  (async () => {\n    for (const apiKey of (data ?? []).map((x) => x.api_key)) {\n      await setCachedACUC(apiKey, is_extract, (acuc) =>\n        acuc\n          ? {\n              ...acuc,\n              credits_used: acuc.credits_used + credits,\n              adjusted_credits_used: acuc.adjusted_credits_used + credits,\n              remaining_credits: acuc.remaining_credits - credits,\n            }\n          : null,\n      );\n      await setCachedACUCTeam(team_id, is_extract, (acuc) =>\n        acuc\n          ? {\n              ...acuc,\n              credits_used: acuc.credits_used + credits,\n              adjusted_credits_used: acuc.adjusted_credits_used + credits,\n              remaining_credits: acuc.remaining_credits - credits,\n            }\n          : null,\n      );\n    }\n  })().catch(error => {\n    _logger.error(\"Failed to update cached credits\", { error, team_id });\n  });\n\n  return { success: true, data };\n}\n\n// Cleanup on exit\nprocess.on(\"beforeExit\", async () => {\n  if (batchInterval) {\n    clearInterval(batchInterval);\n    batchInterval = null;\n    logger.info(\"Stopped periodic billing batch processing\");\n  }\n  await processBillingBatch();\n}); "]}