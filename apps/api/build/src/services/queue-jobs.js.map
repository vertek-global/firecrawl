{"version":3,"file":"queue-jobs.js","sourceRoot":"","sources":["../../../src/services/queue-jobs.ts"],"names":[],"mappings":"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","sourcesContent":["import { getScrapeQueue } from \"./queue-service\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { NotificationType, RateLimiterMode, WebScraperOptions } from \"../types\";\nimport * as Sentry from \"@sentry/node\";\nimport {\n  cleanOldConcurrencyLimitEntries,\n  getConcurrencyLimitActiveJobs,\n  getConcurrencyQueueJobsCount,\n  getCrawlConcurrencyLimitActiveJobs,\n  pushConcurrencyLimitActiveJob,\n  pushConcurrencyLimitedJob,\n  pushCrawlConcurrencyLimitActiveJob,\n} from \"../lib/concurrency-limit\";\nimport { logger } from \"../lib/logger\";\nimport { sendNotificationWithCustomDays } from './notification/email_notification';\nimport { shouldSendConcurrencyLimitNotification } from './notification/notification-check';\nimport { getACUC, getACUCTeam } from \"../controllers/auth\";\nimport { getJobFromGCS, removeJobFromGCS } from \"../lib/gcs-jobs\";\nimport { Document } from \"../controllers/v1/types\";\nimport { getCrawl } from \"../lib/crawl-redis\";\n\n/**\n * Checks if a job is a crawl or batch scrape based on its options\n * @param options The job options containing crawlerOptions and crawl_id\n * @returns true if the job is either a crawl or batch scrape\n */\nfunction isCrawlOrBatchScrape(options: { crawlerOptions?: any; crawl_id?: string }): boolean {\n  // If crawlerOptions exists, it's a crawl\n  // If crawl_id exists but no crawlerOptions, it's a batch scrape\n  return !!options.crawlerOptions || !!options.crawl_id;\n}\n\nasync function _addScrapeJobToConcurrencyQueue(\n  webScraperOptions: any,\n  options: any,\n  jobId: string,\n  jobPriority: number,\n) {\n  await pushConcurrencyLimitedJob(webScraperOptions.team_id, {\n    id: jobId,\n    data: webScraperOptions,\n    opts: {\n      ...options,\n      priority: jobPriority,\n      jobId: jobId,\n    },\n    priority: jobPriority,\n  }, webScraperOptions.crawl_id ? Infinity :(webScraperOptions.scrapeOptions?.timeout ?? (60 * 1000)));\n}\n\nexport async function _addScrapeJobToBullMQ(\n  webScraperOptions: WebScraperOptions,\n  options: any,\n  jobId: string,\n  jobPriority: number,\n) {\n  if (\n    webScraperOptions &&\n    webScraperOptions.team_id\n  ) {\n    await pushConcurrencyLimitActiveJob(webScraperOptions.team_id, jobId, 60 * 1000); // 60s default timeout\n\n    if (webScraperOptions.crawl_id) {\n      const sc = await getCrawl(webScraperOptions.crawl_id);\n      if (webScraperOptions.crawlerOptions?.delay || sc?.maxConcurrency) {\n        await pushCrawlConcurrencyLimitActiveJob(webScraperOptions.crawl_id, jobId, 60 * 1000);\n      }\n    }\n  }\n\n  await getScrapeQueue().add(jobId, webScraperOptions, {\n    ...options,\n    priority: jobPriority,\n    jobId,\n  });\n}\n\nasync function addScrapeJobRaw(\n  webScraperOptions: WebScraperOptions,\n  options: any,\n  jobId: string,\n  jobPriority: number,\n  directToBullMQ: boolean = false,\n) {\n  let concurrencyLimited: \"yes\" | \"yes-crawl\" | \"no\" | null = null;\n  let currentActiveConcurrency = 0;\n  let maxConcurrency = 0;\n\n  if (directToBullMQ) {\n    concurrencyLimited = \"no\";\n  } else {\n    if (webScraperOptions.crawl_id) {\n      const crawl = await getCrawl(webScraperOptions.crawl_id);\n      const concurrencyLimit = !crawl\n        ? null\n        : crawl.crawlerOptions?.delay === undefined && crawl.maxConcurrency === undefined\n          ? null\n          : crawl.maxConcurrency ?? 1;\n      \n      if (concurrencyLimit !== null) {\n        const crawlConcurrency = (await getCrawlConcurrencyLimitActiveJobs(webScraperOptions.crawl_id)).length;\n        const freeSlots = Math.max(concurrencyLimit - crawlConcurrency, 0);\n        if (freeSlots === 0) {\n          concurrencyLimited = \"yes-crawl\";\n        }\n      }\n    }\n\n    if (concurrencyLimited === null) {\n      const now = Date.now();\n      const maxConcurrency = (await getACUCTeam(webScraperOptions.team_id, false, true, webScraperOptions.is_extract ? RateLimiterMode.Extract : RateLimiterMode.Crawl))?.concurrency ?? 2;\n      await cleanOldConcurrencyLimitEntries(webScraperOptions.team_id, now);\n      const currentActiveConcurrency = (await getConcurrencyLimitActiveJobs(webScraperOptions.team_id, now)).length;\n      concurrencyLimited = currentActiveConcurrency >= maxConcurrency ? \"yes\" : \"no\";\n    }\n  }\n\n  if (concurrencyLimited === \"yes\" || concurrencyLimited === \"yes-crawl\") {\n    if (concurrencyLimited === \"yes\") {\n      // Detect if they hit their concurrent limit\n      // If above by 2x, send them an email\n      // No need to 2x as if there are more than the max concurrency in the concurrency queue, it is already 2x\n      const concurrencyQueueJobs = await getConcurrencyQueueJobsCount(webScraperOptions.team_id);\n      if(concurrencyQueueJobs > maxConcurrency) {\n        // logger.info(\"Concurrency limited 2x (single) - \", \"Concurrency queue jobs: \", concurrencyQueueJobs, \"Max concurrency: \", maxConcurrency, \"Team ID: \", webScraperOptions.team_id);\n\n        // Only send notification if it's not a crawl or batch scrape\n          const shouldSendNotification = await shouldSendConcurrencyLimitNotification(webScraperOptions.team_id);\n          if (shouldSendNotification) {\n            sendNotificationWithCustomDays(webScraperOptions.team_id, NotificationType.CONCURRENCY_LIMIT_REACHED, 15, false, true).catch((error) => {\n              logger.error(\"Error sending notification (concurrency limit reached)\", { error });\n            });\n          }\n      }\n    }\n\n    webScraperOptions.concurrencyLimited = true;\n\n    await _addScrapeJobToConcurrencyQueue(\n      webScraperOptions,\n      options,\n      jobId,\n      jobPriority,\n    );\n  } else {\n    await _addScrapeJobToBullMQ(webScraperOptions, options, jobId, jobPriority);\n  }\n}\n\nexport async function addScrapeJob(\n  webScraperOptions: WebScraperOptions,\n  options: any = {},\n  jobId: string = uuidv4(),\n  jobPriority: number = 10,\n  directToBullMQ: boolean = false,\n) {\n  if (Sentry.isInitialized()) {\n    const size = JSON.stringify(webScraperOptions).length;\n    return await Sentry.startSpan(\n      {\n        name: \"Add scrape job\",\n        op: \"queue.publish\",\n        attributes: {\n          \"messaging.message.id\": jobId,\n          \"messaging.destination.name\": getScrapeQueue().name,\n          \"messaging.message.body.size\": size,\n        },\n      },\n      async (span) => {\n        await addScrapeJobRaw(\n          {\n            ...webScraperOptions,\n            sentry: {\n              trace: Sentry.spanToTraceHeader(span),\n              baggage: Sentry.spanToBaggageHeader(span),\n              size,\n            },\n          },\n          options,\n          jobId,\n          jobPriority,\n          directToBullMQ,\n        );\n      },\n    );\n  } else {\n    await addScrapeJobRaw(webScraperOptions, options, jobId, jobPriority, directToBullMQ);\n  }\n}\n\nexport async function addScrapeJobs(\n  jobs: {\n    data: WebScraperOptions;\n    opts: {\n      jobId: string;\n      priority: number;\n    };\n  }[],\n) {\n  if (jobs.length === 0) return true;\n\n  const jobsByTeam = new Map<string, {\n    data: WebScraperOptions;\n    opts: {\n      jobId: string;\n      priority: number;\n    };\n  }[]>();\n\n  for (const job of jobs) {\n    if (!jobsByTeam.has(job.data.team_id)) {\n      jobsByTeam.set(job.data.team_id, []);\n    }\n    jobsByTeam.get(job.data.team_id)!.push(job);\n  }\n\n  for (const [teamId, teamJobs] of jobsByTeam) {\n    // == Buckets for jobs ==\n    let jobsForcedToCQ: {\n      data: WebScraperOptions;\n      opts: {\n        jobId: string;\n        priority: number;\n      };\n    }[] = [];\n\n    let jobsPotentiallyInCQ: {\n      data: WebScraperOptions;\n      opts: {\n        jobId: string;\n        priority: number;\n      };\n    }[] = [];\n\n    // == Select jobs by crawl ID ==\n    const jobsByCrawlID = new Map<string, {\n      data: WebScraperOptions;\n      opts: {\n        jobId: string;\n        priority: number;\n      };\n    }[]>();\n\n    const jobsWithoutCrawlID: {\n      data: WebScraperOptions;\n      opts: {\n        jobId: string;\n        priority: number;\n      };\n    }[] = [];\n\n    for (const job of teamJobs) {\n      if (job.data.crawl_id) {\n        if (!jobsByCrawlID.has(job.data.crawl_id)) {\n          jobsByCrawlID.set(job.data.crawl_id, []);\n        }\n        jobsByCrawlID.get(job.data.crawl_id)!.push(job);\n      } else {\n        jobsWithoutCrawlID.push(job);\n      }\n    }\n\n    // == Select jobs by crawl ID ==\n    for (const [crawlID, crawlJobs] of jobsByCrawlID) {\n      const crawl = await getCrawl(crawlID);\n      const concurrencyLimit = !crawl\n        ? null\n        : crawl.crawlerOptions?.delay === undefined && crawl.maxConcurrency === undefined\n          ? null\n          : crawl.maxConcurrency ?? 1;\n        \n\n      if (concurrencyLimit === null) {\n        // All jobs may be in the CQ depending on the global team concurrency limit\n        jobsPotentiallyInCQ.push(...crawlJobs);\n      } else {\n        const crawlConcurrency = (await getCrawlConcurrencyLimitActiveJobs(crawlID)).length;\n        const freeSlots = Math.max(concurrencyLimit - crawlConcurrency, 0);\n\n        // The first n jobs may be in the CQ depending on the global team concurrency limit\n        jobsPotentiallyInCQ.push(...crawlJobs.slice(0, freeSlots));\n\n        // Every job after that must be in the CQ, as the crawl concurrency limit has been reached\n        jobsForcedToCQ.push(...crawlJobs.slice(freeSlots));\n      }\n    }\n\n    // All jobs without a crawl ID may be in the CQ depending on the global team concurrency limit\n    jobsPotentiallyInCQ.push(...jobsWithoutCrawlID);\n\n    const now = Date.now();\n    const maxConcurrency = (await getACUCTeam(teamId, false, true, jobs[0].data.from_extract ? RateLimiterMode.Extract : RateLimiterMode.Crawl))?.concurrency ?? 2;\n    await cleanOldConcurrencyLimitEntries(teamId, now);\n\n    const currentActiveConcurrency = (await getConcurrencyLimitActiveJobs(teamId, now)).length;\n\n    const countCanBeDirectlyAdded = Math.max(\n      maxConcurrency - currentActiveConcurrency,\n      0,\n    );\n\n    const addToBull = jobsPotentiallyInCQ.slice(0, countCanBeDirectlyAdded);\n    const addToCQ = jobsPotentiallyInCQ.slice(countCanBeDirectlyAdded).concat(jobsForcedToCQ);\n\n    // equals 2x the max concurrency\n    if((jobsPotentiallyInCQ.length - countCanBeDirectlyAdded) > maxConcurrency) {\n      // logger.info(`Concurrency limited 2x (multiple) - Concurrency queue jobs: ${addToCQ.length} Max concurrency: ${maxConcurrency} Team ID: ${jobs[0].data.team_id}`);\n      // Only send notification if it's not a crawl or batch scrape\n      if (!isCrawlOrBatchScrape(jobs[0].data)) {\n        const shouldSendNotification = await shouldSendConcurrencyLimitNotification(jobs[0].data.team_id);\n        if (shouldSendNotification) {\n          sendNotificationWithCustomDays(jobs[0].data.team_id, NotificationType.CONCURRENCY_LIMIT_REACHED, 15, false, true).catch((error) => {\n            logger.error(\"Error sending notification (concurrency limit reached)\", { error });\n          });\n        }\n      }\n    }\n\n    await Promise.all(\n      addToCQ.map(async (job) => {\n        const size = JSON.stringify(job.data).length;\n        return await Sentry.startSpan(\n          {\n            name: \"Add scrape job\",\n            op: \"queue.publish\",\n            attributes: {\n              \"messaging.message.id\": job.opts.jobId,\n              \"messaging.destination.name\": getScrapeQueue().name,\n              \"messaging.message.body.size\": size,\n            },\n          },\n          async (span) => {\n            const jobData = {\n              ...job.data,\n              sentry: {\n                trace: Sentry.spanToTraceHeader(span),\n                baggage: Sentry.spanToBaggageHeader(span),\n                size,\n              },\n            };\n  \n            await _addScrapeJobToConcurrencyQueue(\n              jobData,\n              job.opts,\n              job.opts.jobId,\n              job.opts.priority,\n            );\n          },\n        );\n      }),\n    );\n  \n    await Promise.all(\n      addToBull.map(async (job) => {\n        const size = JSON.stringify(job.data).length;\n        return await Sentry.startSpan(\n          {\n            name: \"Add scrape job\",\n            op: \"queue.publish\",\n            attributes: {\n              \"messaging.message.id\": job.opts.jobId,\n              \"messaging.destination.name\": getScrapeQueue().name,\n              \"messaging.message.body.size\": size,\n            },\n          },\n          async (span) => {\n            await _addScrapeJobToBullMQ(\n              {\n                ...job.data,\n                sentry: {\n                  trace: Sentry.spanToTraceHeader(span),\n                  baggage: Sentry.spanToBaggageHeader(span),\n                  size,\n                },\n              },\n              job.opts,\n              job.opts.jobId,\n              job.opts.priority,\n            );\n          },\n        );\n      }),\n    );\n  }\n}\n\nexport function waitForJob(\n  jobId: string,\n  timeout: number,\n): Promise<Document> {\n  return new Promise((resolve, reject) => {\n    const start = Date.now();\n    const int = setInterval(async () => {\n      if (Date.now() >= start + timeout) {\n        clearInterval(int);\n        reject(new Error(\"Job wait \"));\n      } else {\n        const state = await getScrapeQueue().getJobState(jobId);\n        if (state === \"completed\") {\n          clearInterval(int);\n          let doc: Document;\n          const job = (await getScrapeQueue().getJob(jobId))!;\n          doc = job.returnvalue;\n\n          if (!doc) {\n            const docs = await getJobFromGCS(jobId);\n            if (!docs || docs.length === 0) {\n              throw new Error(\"Job not found in GCS\");\n            }\n            doc = docs[0];\n\n            if (job.data?.internalOptions?.zeroDataRetention) {\n              await removeJobFromGCS(jobId);\n            }\n          }\n\n          resolve(doc);\n        } else if (state === \"failed\") {\n          const job = await getScrapeQueue().getJob(jobId);\n          if (job && job.failedReason !== \"Concurrency limit hit\") {\n            clearInterval(int);\n            reject(job.failedReason);\n          }\n        }\n      }\n    }, 250);\n  });\n}\n"]}