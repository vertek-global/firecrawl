{"version":3,"file":"concurrency-limit.js","sourceRoot":"","sources":["../../../src/lib/concurrency-limit.ts"],"names":[],"mappings":"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","sourcesContent":["import { RateLimiterMode } from \"../types\";\nimport { redisEvictConnection } from \"../services/redis\";\nimport type { Job, JobsOptions } from \"bullmq\";\nimport { getACUCTeam } from \"../controllers/auth\";\nimport { getCrawl, StoredCrawl } from \"./crawl-redis\";\nimport { getScrapeQueue } from \"../services/queue-service\";\nimport { logger } from \"./logger\";\n\nconst constructKey = (team_id: string) => \"concurrency-limiter:\" + team_id;\nconst constructQueueKey = (team_id: string) =>\n  \"concurrency-limit-queue:\" + team_id;\n\nconst constructCrawlKey = (crawl_id: string) => \"crawl-concurrency-limiter:\" + crawl_id;\n\nexport async function cleanOldConcurrencyLimitEntries(\n  team_id: string,\n  now: number = Date.now(),\n) {\n  await redisEvictConnection.zremrangebyscore(constructKey(team_id), -Infinity, now);\n}\n\nexport async function getConcurrencyLimitActiveJobs(\n  team_id: string,\n  now: number = Date.now(),\n): Promise<string[]> {\n  return await redisEvictConnection.zrangebyscore(\n    constructKey(team_id),\n    now,\n    Infinity,\n  );\n}\n\nexport async function pushConcurrencyLimitActiveJob(\n  team_id: string,\n  id: string,\n  timeout: number,\n  now: number = Date.now(),\n) {\n  await redisEvictConnection.zadd(\n    constructKey(team_id),\n    now + timeout,\n    id,\n  );\n}\n\nexport async function removeConcurrencyLimitActiveJob(\n  team_id: string,\n  id: string,\n) {\n  await redisEvictConnection.zrem(constructKey(team_id), id);\n}\n\nexport type ConcurrencyLimitedJob = {\n  id: string;\n  data: any;\n  opts: JobsOptions;\n  priority?: number;\n};\n\nexport async function takeConcurrencyLimitedJob(\n  team_id: string,\n): Promise<ConcurrencyLimitedJob | null> {\n  await redisEvictConnection.zremrangebyscore(constructQueueKey(team_id), -Infinity, Date.now());\n  const res = await redisEvictConnection.zmpop(1, constructQueueKey(team_id), \"MIN\");\n  if (res === null || res === undefined) {\n    return null;\n  }\n\n  return JSON.parse(res[1][0][0]);\n}\n\nexport async function pushConcurrencyLimitedJob(\n  team_id: string,\n  job: ConcurrencyLimitedJob,\n  timeout: number,\n  now: number = Date.now(),\n) {\n  await redisEvictConnection.zadd(\n    constructQueueKey(team_id),\n    now + timeout,\n    JSON.stringify(job),\n  );\n}\n\nexport async function getConcurrencyLimitedJobs(\n  team_id: string,\n) {\n  return new Set((await redisEvictConnection.zrange(constructQueueKey(team_id), 0, -1)).map(x => JSON.parse(x).id));\n}\n\nexport async function getConcurrencyQueueJobsCount(team_id: string): Promise<number> {\n  const count = await redisEvictConnection.zcard(constructQueueKey(team_id));\n  return count;\n}\n\nexport async function cleanOldCrawlConcurrencyLimitEntries(\n  crawl_id: string,\n  now: number = Date.now(),\n) {\n  await redisEvictConnection.zremrangebyscore(constructCrawlKey(crawl_id), -Infinity, now);\n}\n\nexport async function getCrawlConcurrencyLimitActiveJobs(\n  crawl_id: string,\n  now: number = Date.now(),\n): Promise<string[]> {\n  return await redisEvictConnection.zrangebyscore(\n    constructCrawlKey(crawl_id),\n    now,\n    Infinity,\n  );\n}\n\nexport async function pushCrawlConcurrencyLimitActiveJob(\n  crawl_id: string,\n  id: string,\n  timeout: number,\n  now: number = Date.now(),\n) {\n  await redisEvictConnection.zadd(\n    constructCrawlKey(crawl_id),\n    now + timeout,\n    id,\n  );\n}\n\nexport async function removeCrawlConcurrencyLimitActiveJob(\n  crawl_id: string,\n  id: string,\n) {\n  await redisEvictConnection.zrem(constructCrawlKey(crawl_id), id);\n}\n\n/**\n * Grabs the next job from the team's concurrency limit queue. Handles crawl concurrency limits.\n * \n * This function may only be called once the outer code has verified that the team has not reached its concurrency limit.\n * \n * @param teamId\n * @returns A job that can be run, or null if there are no more jobs to run.\n */\nasync function getNextConcurrentJob(teamId: string, i = 0): Promise<{\n  job: ConcurrencyLimitedJob;\n  timeout: number;\n} | null> {\n  let finalJob: {\n    job: ConcurrencyLimitedJob;\n    _member: string;\n    timeout: number;\n  } | null = null;\n\n  const crawlCache = new Map<string, StoredCrawl>();\n  let cursor: string = \"0\";\n\n  while (true) {\n    const scanResult = await redisEvictConnection.zscan(constructQueueKey(teamId), cursor, \"COUNT\", 1);\n    cursor = scanResult[0];\n    const results = scanResult[1];\n\n    for (let i = 0; i < results.length; i += 2) {\n      const res = {\n        job: JSON.parse(results[i]),\n        _member: results[i],\n        timeout: results[i + 1] === \"inf\" ? Infinity : parseFloat(results[i + 1]),\n      };\n\n      // If the job is associated with a crawl ID, we need to check if the crawl has a max concurrency limit\n      if (res.job.data.crawl_id) {\n        const sc = crawlCache.get(res.job.data.crawl_id) ?? await getCrawl(res.job.data.crawl_id);\n        if (sc !== null) {\n          crawlCache.set(res.job.data.crawl_id, sc);\n        }\n\n        const maxCrawlConcurrency = sc === null\n          ? null\n          : (typeof sc.crawlerOptions?.delay === \"number\")\n            ? 1\n            : sc.maxConcurrency ?? null;\n              \n        if (maxCrawlConcurrency !== null) {\n          // If the crawl has a max concurrency limit, we need to check if the crawl has reached the limit\n          const currentActiveConcurrency = (await getCrawlConcurrencyLimitActiveJobs(res.job.data.crawl_id)).length;\n          if (currentActiveConcurrency < maxCrawlConcurrency) {\n            // If we're under the max concurrency limit, we can run the job\n            finalJob = res;\n          }\n        } else {\n          // If the crawl has no max concurrency limit, we can run the job\n          finalJob = res;\n        }\n      } else {\n        // If the job is not associated with a crawl ID, we can run the job\n        finalJob = res;\n      }\n\n      if (finalJob !== null) {\n        break;\n      }\n    }\n\n    if (finalJob !== null) {\n      break;\n    }\n\n    if (cursor === \"0\") {\n      break;\n    }\n  }\n\n  if (finalJob !== null) {\n    const res = await redisEvictConnection.zrem(constructQueueKey(teamId), finalJob._member);\n    if (res === 0) {\n      // It's normal for this to happen, but if it happens too many times, we should log a warning\n      if (i > 15) {\n        logger.warn(\"Failed to remove job from concurrency limit queue\", {\n          teamId,\n          jobId: finalJob.job.id,\n          zeroDataRetention: finalJob.job.data?.zeroDataRetention,\n          i\n        });\n      }\n      return await getNextConcurrentJob(teamId, i + 1);\n    }\n  }\n\n  return finalJob;\n}\n\n/**\n * Called when a job associated with a concurrency queue is done.\n * \n * @param job The BullMQ job that is done.\n */\nexport async function concurrentJobDone(job: Job) {\n  if (job.id && job.data && job.data.team_id) {\n    await removeConcurrencyLimitActiveJob(job.data.team_id, job.id);\n    await cleanOldConcurrencyLimitEntries(job.data.team_id);\n\n    if (job.data.crawl_id) {\n      await removeCrawlConcurrencyLimitActiveJob(job.data.crawl_id, job.id);\n      await cleanOldCrawlConcurrencyLimitEntries(job.data.crawl_id);\n    }\n\n    const maxTeamConcurrency = (await getACUCTeam(job.data.team_id, false, true, job.data.is_extract ? RateLimiterMode.Extract : RateLimiterMode.Crawl))?.concurrency ?? 2;\n    const currentActiveConcurrency = (await getConcurrencyLimitActiveJobs(job.data.team_id)).length;\n\n    if (currentActiveConcurrency < maxTeamConcurrency) {\n      const nextJob = await getNextConcurrentJob(job.data.team_id);\n      if (nextJob !== null) {\n        await pushConcurrencyLimitActiveJob(job.data.team_id, nextJob.job.id, 60 * 1000);\n\n        if (nextJob.job.data.crawl_id) {\n          await pushCrawlConcurrencyLimitActiveJob(nextJob.job.data.crawl_id, nextJob.job.id, 60 * 1000);\n\n          const sc = await getCrawl(nextJob.job.data.crawl_id);\n          if (sc !== null && typeof sc.crawlerOptions?.delay === \"number\") {\n            await new Promise(resolve => setTimeout(resolve, sc.crawlerOptions.delay * 1000));\n          }\n        }\n\n        (await getScrapeQueue()).add(\n          nextJob.job.id,\n          {\n            ...nextJob.job.data,\n            concurrencyLimitHit: true,\n          },\n          {\n            ...nextJob.job.opts,\n            jobId: nextJob.job.id,\n            priority: nextJob.job.priority,\n          }\n        );\n      }\n    }\n  }\n}\n"]}