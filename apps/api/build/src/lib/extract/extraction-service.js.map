{"version":3,"file":"extraction-service.js","sourceRoot":"","sources":["../../../../src/lib/extract/extraction-service.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  Document,\n  ExtractRequest,\n  isAgentExtractModelValid,\n  TokenUsage,\n  URLTrace,\n} from \"../../controllers/v1/types\";\nimport { logger as _logger } from \"../logger\";\nimport { generateBasicCompletion, processUrl } from \"./url-processor\";\nimport { scrapeDocument } from \"./document-scraper\";\nimport {\n  generateCompletions,\n  generateSchemaFromPrompt,\n} from \"../../scraper/scrapeURL/transformers/llmExtract\";\nimport { billTeam } from \"../../services/billing/credit_billing\";\nimport { logJob } from \"../../services/logging/log_job\";\nimport { _addScrapeJobToBullMQ } from \"../../services/queue-jobs\";\nimport { dereferenceSchema } from \"./helpers/dereference-schema\";\nimport { spreadSchemas } from \"./helpers/spread-schemas\";\nimport { transformArrayToObject } from \"./helpers/transform-array-to-obj\";\nimport { mixSchemaObjects } from \"./helpers/mix-schema-objs\";\nimport Ajv from \"ajv\";\nconst ajv = new Ajv();\n\nimport { ExtractStep, updateExtract } from \"./extract-redis\";\nimport { deduplicateObjectsArray } from \"./helpers/deduplicate-objs-array\";\nimport { mergeNullValObjs } from \"./helpers/merge-null-val-objs\";\nimport { areMergeable } from \"./helpers/merge-null-val-objs\";\nimport { CUSTOM_U_TEAMS } from \"./config\";\nimport { calculateFinalResultCost, calculateThinkingCost, estimateTotalCost } from \"./usage/llm-cost\";\nimport { analyzeSchemaAndPrompt } from \"./completions/analyzeSchemaAndPrompt\";\nimport { batchExtractPromise } from \"./completions/batchExtract\";\nimport { singleAnswerCompletion } from \"./completions/singleAnswer\";\nimport { SourceTracker } from \"./helpers/source-tracker\";\nimport { getCachedDocs, saveCachedDocs } from \"./helpers/cached-docs\";\nimport { normalizeUrl } from \"../canonical-url\";\nimport { search } from \"../../search\";\nimport { buildRephraseToSerpPrompt } from \"./build-prompts\";\nimport { getACUCTeam } from \"../../controllers/auth\";\ninterface ExtractServiceOptions {\n  request: ExtractRequest;\n  teamId: string;\n  subId?: string;\n  cacheMode?: \"load\" | \"save\" | \"direct\";\n  cacheKey?: string;\n  agent?: boolean;\n}\n\nexport interface ExtractResult {\n  success: boolean;\n  data?: any;\n  extractId: string;\n  warning?: string;\n  urlTrace?: URLTrace[];\n  error?: string;\n  tokenUsageBreakdown?: TokenUsage[];\n  llmUsage?: number;\n  totalUrlsScraped?: number;\n  sources?: Record<string, string[]>;\n}\n\ntype completions = {\n  extract: Record<string, any>;\n  numTokens: number;\n  totalUsage: TokenUsage;\n  warning?: string;\n  sources?: string[];\n};\n\nexport class CostLimitExceededError extends Error {\n  constructor() {\n    super(\"Cost limit exceeded\");\n    this.message = \"Cost limit exceeded\";\n    this.name = \"CostLimitExceededError\";\n  }\n}\n\nconst nanProof = (n: number | null | undefined) => isNaN(n ?? 0) ? 0 : (n ?? 0);\n\nexport class CostTracking {\n  calls: {\n    type: \"smartScrape\" | \"other\",\n    metadata: Record<string, any>,\n    cost: number,\n    model: string,\n    tokens?: {\n      input: number,\n      output: number,\n    },\n    stack: string,\n  }[] = [];\n  limit: number | null = null;\n\n  constructor(limit: number | null = null) {\n    this.limit = limit;\n  }\n\n  public addCall(call: Omit<typeof this.calls[number], \"stack\">) {\n    this.calls.push({\n      ...call,\n      stack: new Error().stack!.split(\"\\n\").slice(2).join(\"\\n\"),\n    });\n\n    if (this.limit !== null && this.toJSON().totalCost > this.limit) {\n      throw new CostLimitExceededError();\n    }\n  }\n\n  public toJSON() {\n    return {\n      calls: this.calls,\n\n      smartScrapeCallCount: this.calls.filter(c => c.type === \"smartScrape\").length,\n      smartScrapeCost: this.calls.filter(c => c.type === \"smartScrape\").reduce((acc, c) => acc + nanProof(c.cost), 0),\n      otherCallCount: this.calls.filter(c => c.type === \"other\").length,\n      otherCost: this.calls.filter(c => c.type === \"other\").reduce((acc, c) => acc + nanProof(c.cost), 0),\n      totalCost: this.calls.reduce((acc, c) => acc + nanProof(c.cost), 0),\n    }\n  }\n}\n\nexport async function performExtraction(\n  extractId: string,\n  options: ExtractServiceOptions,\n): Promise<ExtractResult> {\n  const { request, teamId, subId } = options;\n  const urlTraces: URLTrace[] = [];\n  let docsMap: Map<string, Document> = new Map();\n  let singleAnswerCompletions: completions | null = null;\n  let multiEntityCompletions: completions[] = [];\n  let multiEntityResult: any = {};\n  let singleAnswerResult: any = {};\n  let totalUrlsScraped = 0;\n  let sources: Record<string, string[]> = {};\n\n  let costTracking = new CostTracking(subId ? null : 1.5);\n  const acuc = await getACUCTeam(teamId);\n\n  let log = {\n    extractId,\n    request,\n  };\n\n  const logger = _logger.child({\n    module: \"extract\",\n    method: \"performExtraction\",\n    extractId,\n    teamId,\n  });\n\n  try {\n\n    // If no URLs are provided, generate URLs from the prompt\n    if ((!request.urls || request.urls.length === 0) && request.prompt) {\n      logger.debug(\"Generating URLs from prompt...\", {\n        prompt: request.prompt,\n      });\n      const rephrasedPrompt = await generateBasicCompletion(\n        buildRephraseToSerpPrompt(request.prompt),\n        costTracking,\n      );\n      let rptxt = rephrasedPrompt?.text.replace('\"', \"\").replace(\"'\", \"\") || \"\";\n      const searchResults = await search({\n        query: rptxt,\n        num_results: 10,\n      });\n\n      request.urls = searchResults.map((result) => result.url) as string[];\n    }\n    if (request.urls && request.urls.length === 0) {\n      logger.error(\"No search results found\", {\n        query: request.prompt,\n      });\n\n      const tokens_billed = 300 + calculateThinkingCost(costTracking);\n      logJob({\n        job_id: extractId,\n        success: false,\n        message: \"No search results found\",\n        num_docs: 1,\n        docs: [],\n        time_taken: (new Date().getTime() - Date.now()) / 1000,\n        team_id: teamId,\n        mode: \"extract\",\n        url: request.urls?.join(\", \") || \"\",\n        scrapeOptions: request,\n        origin: request.origin ?? \"api\",\n        integration: request.integration,\n        num_tokens: 0,\n        tokens_billed,\n        sources,\n        cost_tracking: costTracking,\n        zeroDataRetention: false, // not supported\n      });\n\n      await billTeam(teamId, subId, tokens_billed, logger, true).catch((error) => {\n        logger.error(\n          `Failed to bill team ${teamId} for thinking tokens: ${error}`,\n        );\n      });\n\n      return {\n        success: false,\n        error: \"No search results found\",\n        extractId,\n      };\n    }\n\n    const urls = request.urls || ([] as string[]);\n\n    if (\n      request.__experimental_cacheMode == \"load\" &&\n      request.__experimental_cacheKey &&\n      urls\n    ) {\n      logger.debug(\"Loading cached docs...\");\n      try {\n        const cache = await getCachedDocs(urls, request.__experimental_cacheKey);\n        for (const doc of cache) {\n          if (doc.metadata.url) {\n            docsMap.set(normalizeUrl(doc.metadata.url), doc);\n          }\n        }\n      } catch (error) {\n        logger.error(\"Error loading cached docs\", { error });\n      }\n    }\n\n    // Token tracking\n    let tokenUsage: TokenUsage[] = [];\n\n    await updateExtract(extractId, {\n      status: \"processing\",\n      steps: [\n        {\n          step: ExtractStep.INITIAL,\n          startedAt: Date.now(),\n          finishedAt: Date.now(),\n          discoveredLinks: request.urls,\n        },\n      ],\n    });\n\n    let reqSchema = request.schema;\n    if (!reqSchema && request.prompt) {\n      const schemaGenRes = await generateSchemaFromPrompt(request.prompt, logger, costTracking);\n      reqSchema = schemaGenRes.extract;\n\n\n      logger.debug(\"Generated request schema.\", {\n        originalSchema: request.schema,\n        schema: reqSchema,\n      });\n    }\n\n    if (reqSchema) {\n      reqSchema = await dereferenceSchema(reqSchema);\n    }\n\n    logger.debug(\"Transformed schema.\", {\n      originalSchema: request.schema,\n      schema: reqSchema,\n    });\n\n    let rSchema = reqSchema;\n\n    // agent evaluates if the schema or the prompt has an array with big amount of items\n    // also it checks if the schema any other properties that are not arrays\n    // if so, it splits the results into 2 types of completions:\n    // 1. the first one is a completion that will extract the array of items\n    // 2. the second one is multiple completions that will extract the items from the array\n    let startAnalyze = Date.now();\n    const {\n      isMultiEntity,\n      multiEntityKeys,\n      reasoning,\n      keyIndicators,\n      tokenUsage: schemaAnalysisTokenUsage,\n    } = await analyzeSchemaAndPrompt(urls, reqSchema, request.prompt ?? \"\", logger, costTracking);\n\n    logger.debug(\"Analyzed schema.\", {\n      isMultiEntity,\n      multiEntityKeys,\n      reasoning,\n      keyIndicators,\n    });\n\n    tokenUsage.push(schemaAnalysisTokenUsage);\n\n    let startMap = Date.now();\n    let aggMapLinks: string[] = [];\n    logger.debug(\"Processing URLs...\", {\n      urlCount: request.urls?.length || 0,\n    });\n\n    const urlPromises = urls.map((url) =>\n      processUrl(\n        {\n          url,\n          prompt: request.prompt,\n          teamId,\n          allowExternalLinks: request.allowExternalLinks,\n          origin: request.origin,\n          limit: request.limit,\n          includeSubdomains: request.includeSubdomains,\n          schema: request.schema,\n          log,\n          isMultiEntity,\n          reasoning,\n          multiEntityKeys,\n          keyIndicators,\n        },\n        urlTraces,\n        (links: string[]) => {\n          aggMapLinks.push(...links);\n          updateExtract(extractId, {\n            steps: [\n              {\n                step: ExtractStep.MAP,\n                startedAt: startMap,\n                finishedAt: Date.now(),\n                discoveredLinks: aggMapLinks,\n              },\n            ],\n          });\n        },\n        logger.child({ module: \"extract\", method: \"processUrl\", url }),\n        costTracking,\n        acuc?.flags ?? null,\n      ),\n    );\n\n    const processedUrls = await Promise.all(urlPromises);\n    let links = processedUrls.flat().filter((url) => url);\n    logger.debug(\"Processed URLs.\", {\n      linkCount: links.length,\n    });\n\n    if (links.length === 0) {\n      links = urls.map(x => x.replace(/\\*$/g, \"\"));\n      logger.warn(\"0 links! Doing just the original URLs. (without * wildcard)\", {\n        linkCount: links.length,\n      });\n    }\n\n    log[\"links\"] = links;\n    log[\"linksLength\"] = links.length;\n\n    await updateExtract(extractId, {\n      status: \"processing\",\n      steps: [\n        {\n          step: ExtractStep.MAP_RERANK,\n          startedAt: startMap,\n          finishedAt: Date.now(),\n          discoveredLinks: links,\n        },\n      ],\n    });\n\n    if (isMultiEntity && reqSchema) {\n      log[\"isMultiEntity\"] = true;\n      logger.debug(\"=== MULTI-ENTITY ===\");\n\n      const { singleAnswerSchema, multiEntitySchema } = await spreadSchemas(\n        reqSchema,\n        multiEntityKeys,\n      );\n      rSchema = singleAnswerSchema;\n      logger.debug(\"Spread schemas.\", { singleAnswerSchema, multiEntitySchema });\n\n      await updateExtract(extractId, {\n        status: \"processing\",\n        steps: [\n          {\n            step: ExtractStep.MULTI_ENTITY,\n            startedAt: startAnalyze,\n            finishedAt: Date.now(),\n            discoveredLinks: [],\n          },\n        ],\n      });\n\n      const timeout = 60000;\n\n      await updateExtract(extractId, {\n        status: \"processing\",\n        steps: [\n          {\n            step: ExtractStep.MULTI_ENTITY_SCRAPE,\n            startedAt: startAnalyze,\n            finishedAt: Date.now(),\n            discoveredLinks: links,\n          },\n        ],\n      });\n\n      logger.debug(\"Starting multi-entity scrape...\");\n      let startScrape = Date.now();\n      log[\"docsSizeBeforeMultiEntityScrape\"] = docsMap.size;\n\n      const scrapePromises = links.map((url) => {\n        if (!docsMap.has(normalizeUrl(url))) {\n          return scrapeDocument(\n            {\n              url,\n              teamId,\n              origin: \"extract\",\n              timeout,\n            },\n            urlTraces,\n            logger.child({\n              module: \"extract\",\n              method: \"scrapeDocument\",\n              url,\n              isMultiEntity: true,\n            }),\n            {\n              timeout: 300000,\n              ...request.scrapeOptions,\n\n              // Needs to be true for multi-entity to work properly\n              onlyMainContent: true,\n            },\n          );\n        }\n        return docsMap.get(normalizeUrl(url));\n      });\n\n      let multyEntityDocs = (await Promise.all(scrapePromises)).filter(\n        (doc): doc is Document => doc !== null,\n      );\n\n      log[\"docsSizeAfterMultiEntityScrape\"] = scrapePromises.length;\n\n      logger.debug(\"Multi-entity scrape finished.\", {\n        docCount: multyEntityDocs.length,\n      });\n\n      totalUrlsScraped += multyEntityDocs.length;\n\n      let endScrape = Date.now();\n\n      await updateExtract(extractId, {\n        status: \"processing\",\n        steps: [\n          {\n            step: ExtractStep.MULTI_ENTITY_SCRAPE,\n            startedAt: startScrape,\n            finishedAt: endScrape,\n            discoveredLinks: links,\n          },\n        ],\n      });\n\n      for (const doc of multyEntityDocs) {\n        if (doc?.metadata?.url) {\n          docsMap.set(normalizeUrl(doc.metadata.url), doc);\n        }\n      }\n\n      logger.debug(\"Updated docsMap.\", { docsMapSize: docsMap.size }); // useful for error probing\n\n      // Process docs in chunks with queue style processing\n      const chunkSize = 50;\n      const timeoutCompletion = 45000; // 45 second timeout\n      const chunks: Document[][] = [];\n      const extractionResults: { extract: any; url: string }[] = [];\n\n      // Split into chunks\n      for (let i = 0; i < multyEntityDocs.length; i += chunkSize) {\n        chunks.push(multyEntityDocs.slice(i, i + chunkSize));\n      }\n\n      const sessionIds = chunks.map(() => 'fc-' + crypto.randomUUID());\n      await updateExtract(extractId, {\n        status: \"processing\",\n        steps: [\n          {\n            step: ExtractStep.MULTI_ENTITY_AGENT_SCRAPE,\n            startedAt: Date.now(),\n            finishedAt: null\n          },\n        ],\n        sessionIds\n      });\n\n      // Process chunks sequentially with timeout\n      for (let i = 0; i < chunks.length; i++) {\n        const chunk = chunks[i];\n        const sessionId = sessionIds[i];\n        const chunkPromises = chunk.map(async (doc) => {\n          try {\n            ajv.compile(multiEntitySchema);\n\n            // Wrap in timeout promise\n            const timeoutPromise = new Promise((resolve) => {\n              setTimeout(() => resolve(null), timeoutCompletion);\n            });\n\n            const completionPromise = batchExtractPromise({\n              multiEntitySchema,\n              links,\n              prompt: request.prompt ?? \"\",\n              systemPrompt: request.systemPrompt ?? \"\",\n              doc,\n              useAgent: isAgentExtractModelValid(request.agent?.model),\n              extractId,\n              sessionId,\n              costTracking,\n            }, logger);\n\n            // Race between timeout and completion\n            const multiEntityCompletion = (await completionPromise) as Awaited<\n              ReturnType<typeof batchExtractPromise>\n            >;\n\n            // TODO: merge multiEntityCompletion.extract to fit the multiEntitySchema\n\n            // Track multi-entity extraction tokens\n            if (multiEntityCompletion) {\n              tokenUsage.push(multiEntityCompletion.totalUsage);\n\n              if (multiEntityCompletion.extract) {\n                return {\n                  extract: multiEntityCompletion.extract,\n                  url: doc.metadata.url || doc.metadata.sourceURL || \"\",\n                };\n              }\n            }\n\n            // console.log(multiEntityCompletion.extract)\n            // if (!multiEntityCompletion.extract?.is_content_relevant) {\n            //   console.log(`Skipping extraction for ${doc.metadata.url} as content is not relevant`);\n            //   return null;\n            // }\n\n            // Update token usage in traces\n            // if (multiEntityCompletion && multiEntityCompletion.numTokens) {\n            //   const totalLength = docs.reduce(\n            //     (sum, doc) => sum + (doc.markdown?.length || 0),\n            //     0,\n            //   );\n            //   docs.forEach((doc) => {\n            //     if (doc.metadata?.sourceURL) {\n            //       const trace = urlTraces.find(\n            //         (t) => t.url === doc.metadata.sourceURL,\n            //       );\n            //       if (trace && trace.contentStats) {\n            //         trace.contentStats.tokensUsed = Math.floor(\n            //           ((doc.markdown?.length || 0) / totalLength) *\n            //             (multiEntityCompletion?.numTokens || 0),\n            //         );\n            //       }\n            //     }\n            //   });\n            //  }\n\n            // if (multiEntityCompletion.extract && multiEntityCompletion.extract.extraction_confidence < 3) {\n            //   console.log(`Skipping extraction for ${doc.metadata.url} as confidence is too low (${multiEntityCompletion.extract.extraction_confidence})`);\n            //   return null;\n            // }\n\n            return null;\n          } catch (error) {\n            if (error instanceof CostLimitExceededError) {\n              throw error;\n            }\n\n            logger.error(`Failed to process document.`, {\n              error,\n              url: doc.metadata.url ?? doc.metadata.sourceURL!,\n            });\n            return null;\n          }\n        });\n        // Wait for current chunk to complete before processing next chunk\n        const chunkResults = await Promise.all(chunkPromises);\n        const validResults = chunkResults.filter(\n          (result): result is { extract: any; url: string } => result !== null,\n        );\n        extractionResults.push(...validResults);\n        // Merge all extracts from valid results into a single array\n        const extractArrays = validResults.map((r) =>\n          Array.isArray(r.extract) ? r.extract : [r.extract],\n        );\n        const mergedExtracts = extractArrays.flat();\n        multiEntityCompletions.push(...mergedExtracts);\n        multiEntityCompletions = multiEntityCompletions.filter((c) => c !== null);\n        logger.debug(\"All multi-entity completion chunks finished.\", {\n          completionCount: multiEntityCompletions.length,\n        });\n        log[\"multiEntityCompletionsLength\"] = multiEntityCompletions.length;\n      }\n\n      try {\n        // Use SourceTracker to handle source tracking\n        const sourceTracker = new SourceTracker();\n        logger.debug(\"Created SourceTracker instance\");\n\n        // Transform and merge results while preserving sources\n        try {\n          sourceTracker.transformResults(\n            extractionResults,\n            multiEntitySchema,\n            false,\n          );\n          logger.debug(\"Successfully transformed results with sourceTracker\");\n        } catch (error) {\n          logger.error(`Error in sourceTracker.transformResults:`, { error });\n          throw error;\n        }\n\n        try {\n          multiEntityResult = transformArrayToObject(\n            multiEntitySchema,\n            multiEntityCompletions,\n          );\n          logger.debug(\"Successfully transformed array to object\");\n        } catch (error) {\n          logger.error(`Error in transformArrayToObject:`, { error });\n          throw error;\n        }\n\n        // Track sources before deduplication\n        try {\n          sourceTracker.trackPreDeduplicationSources(multiEntityResult);\n          logger.debug(\"Successfully tracked pre-deduplication sources\");\n        } catch (error) {\n          logger.error(`Error in trackPreDeduplicationSources:`, { error });\n          throw error;\n        }\n\n        // Apply deduplication and merge\n        try {\n          multiEntityResult = deduplicateObjectsArray(multiEntityResult);\n          logger.debug(\"Successfully deduplicated objects array\");\n        } catch (error) {\n          logger.error(`Error in deduplicateObjectsArray:`, { error });\n          throw error;\n        }\n\n        try {\n          multiEntityResult = mergeNullValObjs(multiEntityResult);\n          logger.debug(\"Successfully merged null value objects\");\n        } catch (error) {\n          logger.error(`Error in mergeNullValObjs:`, { error });\n          throw error;\n        }\n\n        // Map sources to final deduplicated/merged items\n        try {\n          const multiEntitySources = sourceTracker.mapSourcesToFinalItems(\n            multiEntityResult,\n            multiEntityKeys,\n          );\n          Object.assign(sources, multiEntitySources);\n          logger.debug(\"Successfully mapped sources to final items\");\n        } catch (error) {\n          logger.error(`Error in mapSourcesToFinalItems:`, { error });\n          throw error;\n        }\n      } catch (error) {\n        logger.error(`Failed to transform array to object`, { \n          error,\n          errorMessage: error.message,\n          errorStack: error.stack,\n          multiEntityResult: JSON.stringify(multiEntityResult),\n          multiEntityCompletions: JSON.stringify(multiEntityCompletions),\n          multiEntitySchema: JSON.stringify(multiEntitySchema)\n        });\n        const tokens_billed = 300 + calculateThinkingCost(costTracking);\n        logJob({\n          job_id: extractId,\n          success: false,\n          message: (error instanceof Error ? error.message : \"Failed to transform array to object\"),\n          num_docs: 1,\n          docs: [],\n          time_taken: (new Date().getTime() - Date.now()) / 1000,\n          team_id: teamId,\n          mode: \"extract\",\n          url: request.urls?.join(\", \") || \"\",\n          scrapeOptions: request,\n          origin: request.origin ?? \"api\",\n          integration: request.integration,\n          num_tokens: 0,\n          tokens_billed,\n          sources,\n          cost_tracking: costTracking,\n          zeroDataRetention: false, // not supported\n        });\n        await billTeam(teamId, subId, tokens_billed, logger, true).catch((error) => {\n          logger.error(\n            `Failed to bill team ${teamId} for thinking tokens: ${error}`,\n          );\n        });\n        return {\n          success: false,\n          error:\n            \"An unexpected error occurred. Please contact help@firecrawl.com for help.\",\n          extractId,\n          urlTrace: urlTraces,\n          totalUrlsScraped,\n        };\n      }\n    }\n    if (\n      rSchema &&\n      Object.keys(rSchema).length > 0 &&\n      rSchema.properties &&\n      Object.keys(rSchema.properties).length > 0\n    ) {\n      log[\"isSingleEntity\"] = true;\n      logger.debug(\"=== SINGLE PAGES ===\", {\n        linkCount: links.length,\n        schema: rSchema,\n      });\n\n      // Scrape documents\n      const timeout = 60000;\n      let singleAnswerDocs: Document[] = [];\n\n      // let rerank = await rerankLinks(links.map((url) => ({ url })), request.prompt ?? JSON.stringify(request.schema), urlTraces);\n\n      await updateExtract(extractId, {\n        status: \"processing\",\n        steps: [\n          {\n            step: ExtractStep.SCRAPE,\n            startedAt: Date.now(),\n            finishedAt: Date.now(),\n            discoveredLinks: links,\n          },\n        ],\n      });\n      log[\"docsSizeBeforeSingleEntityScrape\"] = docsMap.size;\n      const scrapePromises = links.map((url) => {\n        if (!docsMap.has(normalizeUrl(url))) {\n          return scrapeDocument(\n            {\n              url,\n              teamId,\n              origin: \"extract\",\n              timeout,\n            },\n            urlTraces,\n            logger.child({\n              module: \"extract\",\n              method: \"scrapeDocument\",\n              url,\n              isMultiEntity: false,\n            }),\n            {\n              timeout: 300000,\n              ...request.scrapeOptions,\n            },\n          );\n        }\n        return docsMap.get(normalizeUrl(url));\n      });\n\n      try {\n        const results = await Promise.all(scrapePromises);\n        log[\"docsSizeAfterSingleEntityScrape\"] = docsMap.size;\n\n        for (const doc of results) {\n          if (doc?.metadata?.url) {\n            docsMap.set(normalizeUrl(doc.metadata.url), doc);\n          }\n        }\n        logger.debug(\"Updated docsMap.\", { docsMapSize: docsMap.size }); // useful for error probing\n\n        const validResults = results.filter(\n          (doc): doc is Document => doc !== null,\n        );\n        singleAnswerDocs.push(...validResults);\n        totalUrlsScraped += validResults.length;\n\n        logger.debug(\"Scrapes finished.\", { docCount: validResults.length });\n      } catch (error) {\n        const tokens_billed = 300 + calculateThinkingCost(costTracking);\n        logJob({\n          job_id: extractId,\n          success: false,\n          message: error.message,\n          num_docs: 1,\n          docs: [],\n          time_taken: (new Date().getTime() - Date.now()) / 1000,\n          team_id: teamId,\n          mode: \"extract\",\n          url: request.urls?.join(\", \") || \"\",\n          scrapeOptions: request,\n          origin: request.origin ?? \"api\",\n          integration: request.integration,\n          num_tokens: 0,\n          tokens_billed,\n          sources,\n          cost_tracking: costTracking,\n          zeroDataRetention: false, // not supported\n        });\n        await billTeam(teamId, subId, tokens_billed, logger, true).catch((error) => {\n          logger.error(\n            `Failed to bill team ${teamId} for thinking tokens: ${error}`,\n          );\n        });\n        return {\n          success: false,\n          error: error.message,\n          extractId,\n          urlTrace: urlTraces,\n          totalUrlsScraped,\n        };\n      }\n\n      if (docsMap.size == 0) {\n        // All urls are invalid\n        logger.error(\"All provided URLs are invalid!\");\n        const tokens_billed = 300 + calculateThinkingCost(costTracking);\n        await billTeam(teamId, subId, tokens_billed, logger, true).catch((error) => {\n          logger.error(\n            `Failed to bill team ${teamId} for thinking tokens: ${error}`,\n          );\n        });\n        logJob({\n          job_id: extractId,\n          success: false,\n          message: \"All provided URLs are invalid. Please check your input and try again.\",\n          num_docs: 1,\n          docs: [],\n          time_taken: (new Date().getTime() - Date.now()) / 1000,\n          team_id: teamId,\n          mode: \"extract\",\n          url: request.urls?.join(\", \") || \"\",\n          scrapeOptions: request,\n          origin: request.origin ?? \"api\",\n          integration: request.integration,\n          num_tokens: 0,\n          tokens_billed,\n          sources,\n          cost_tracking: costTracking,\n          zeroDataRetention: false, // not supported\n        });\n        return {\n          success: false,\n          error:\n            \"All provided URLs are invalid. Please check your input and try again.\",\n          extractId,\n          urlTrace: request.urlTrace ? urlTraces : undefined,\n          totalUrlsScraped: 0,\n        };\n      }\n\n      let thisSessionId = 'fc-' + crypto.randomUUID();\n\n      await updateExtract(extractId, {\n        status: \"processing\",\n        steps: [\n          {\n            step: ExtractStep.EXTRACT,\n            startedAt: Date.now(),\n            finishedAt: Date.now(),\n            discoveredLinks: links,\n          },\n        ],\n        sessionIds: [thisSessionId],\n      });\n\n      // Generate completions\n      logger.debug(\"Generating singleAnswer completions...\");\n      log[\"singleAnswerDocsLength\"] = singleAnswerDocs.length;\n      let {\n        extract: completionResult,\n        tokenUsage: singleAnswerTokenUsage,\n        sources: singleAnswerSources,\n      } = await singleAnswerCompletion({\n        singleAnswerDocs,\n        rSchema,\n        links,\n        prompt: request.prompt ?? \"\",\n        systemPrompt: request.systemPrompt ?? \"\",\n        useAgent: isAgentExtractModelValid(request.agent?.model),\n        extractId,\n        sessionId: thisSessionId,\n        costTracking,\n      });\n      logger.debug(\"Done generating singleAnswer completions.\");\n\n      singleAnswerResult = transformArrayToObject(rSchema, completionResult);\n\n      singleAnswerResult = deduplicateObjectsArray(singleAnswerResult);\n      // Track single answer extraction tokens and sources\n      if (completionResult) {\n        tokenUsage.push(singleAnswerTokenUsage);\n\n        // Add sources for top-level properties in single answer\n        if (rSchema?.properties) {\n          Object.keys(rSchema.properties).forEach((key) => {\n            if (completionResult[key] !== undefined) {\n              sources[key] =\n                singleAnswerSources ||\n                singleAnswerDocs.map(\n                  (doc) => doc.metadata.url || doc.metadata.sourceURL || \"\",\n                );\n            }\n          });\n        }\n      }\n\n      // singleAnswerResult = completionResult;\n      // singleAnswerCompletions = singleAnswerResult;\n\n      // Update token usage in traces\n      // if (completions && completions.numTokens) {\n      //   const totalLength = docs.reduce(\n      //     (sum, doc) => sum + (doc.markdown?.length || 0),\n      //     0,\n      //   );\n      //   docs.forEach((doc) => {\n      //     if (doc.metadata?.sourceURL) {\n      //       const trace = urlTraces.find((t) => t.url === doc.metadata.sourceURL);\n      //       if (trace && trace.contentStats) {\n      //         trace.contentStats.tokensUsed = Math.floor(\n      //           ((doc.markdown?.length || 0) / totalLength) *\n      //             (completions?.numTokens || 0),\n      //         );\n      //       }\n      //     }\n      //   });\n      // }\n    }\n\n    log[\"singleAnswerResult\"] = singleAnswerResult;\n    log[\"multiEntityResult\"] = multiEntityResult;\n\n    let finalResult = reqSchema\n      ? await mixSchemaObjects(\n          reqSchema,\n          singleAnswerResult,\n          multiEntityResult,\n          logger.child({ method: \"mixSchemaObjects\" }),\n        )\n      : singleAnswerResult || multiEntityResult;\n\n    // Tokenize final result to get token count\n    // let finalResultTokens = 0;\n    // if (finalResult) {\n    //   const finalResultStr = JSON.stringify(finalResult);\n    //   finalResultTokens = numTokensFromString(finalResultStr, \"gpt-4o\");\n\n    // }\n    // // Deduplicate and validate final result against schema\n    // if (reqSchema && finalResult && finalResult.length <= extractConfig.DEDUPLICATION.MAX_TOKENS) {\n    //   const schemaValidation = await generateCompletions(\n    //     logger.child({ method: \"extractService/validateAndDeduplicate\" }),\n    //     {\n    //       mode: \"llm\",\n    //       systemPrompt: `You are a data validator and deduplicator. Your task is to:\n    //       1. Remove any duplicate entries in the data extracted by merging that into a single object according to the provided shcema\n    //       2. Ensure all data matches the provided schema\n    //       3. Keep only the highest quality and most complete entries when duplicates are found.\n\n    //       Do not change anything else. If data is null keep it null. If the schema is not provided, return the data as is.`,\n    //       prompt: `Please validate and merge the duplicate entries in this data according to the schema provided:\\n\n\n    //       <start of extract data>\n\n    //       ${JSON.stringify(finalResult)}\n\n    //       <end of extract data>\n\n    //       <start of schema>\n\n    //       ${JSON.stringify(reqSchema)}\n\n    //       <end of schema>\n    //       `,\n    //       schema: reqSchema,\n    //     },\n    //     undefined,\n    //     undefined,\n    //     true,\n    //     \"gpt-4o\"\n    //   );\n    //   console.log(\"schemaValidation\", schemaValidation);\n\n    //   console.log(\"schemaValidation\", finalResult);\n\n    //   if (schemaValidation?.extract) {\n    //     tokenUsage.push(schemaValidation.totalUsage);\n    //     finalResult = schemaValidation.extract;\n    //   }\n    // }\n\n    const totalTokensUsed = tokenUsage.reduce((a, b) => a + b.totalTokens, 0);\n    const llmUsage = estimateTotalCost(tokenUsage);\n    let tokensToBill = calculateFinalResultCost(finalResult) + calculateThinkingCost(costTracking);\n\n    if (CUSTOM_U_TEAMS.includes(teamId)) {\n      tokensToBill = 1;\n    }\n\n    // Bill team for usage\n    await billTeam(teamId, subId, tokensToBill, logger, true).catch((error) => {\n      logger.error(\n        `Failed to bill team ${teamId} for ${tokensToBill} tokens: ${error}`,\n      );\n    });\n\n    // Log job with token usage and sources\n    logJob({\n      job_id: extractId,\n      success: true,\n      message: \"Extract completed\",\n      num_docs: 1,\n      docs: finalResult ?? {},\n      time_taken: (new Date().getTime() - Date.now()) / 1000,\n      team_id: teamId,\n      mode: \"extract\",\n      url: request.urls?.join(\", \") || \"\",\n      scrapeOptions: request,\n      origin: request.origin ?? \"api\",\n      integration: request.integration,\n      num_tokens: totalTokensUsed,\n      tokens_billed: tokensToBill,\n      sources,\n      cost_tracking: costTracking,\n      zeroDataRetention: false, // not supported\n    }).then(() => {\n      updateExtract(extractId, {\n        status: \"completed\",\n        llmUsage,\n        sources,\n        tokensBilled: tokensToBill,\n        // costTracking,\n      }).catch((error) => {\n        logger.error(\n          `Failed to update extract ${extractId} status to completed: ${error}`,\n        );\n      });\n    });\n\n    logger.debug(\"Done!\");\n\n    if (\n      request.__experimental_cacheMode == \"save\" &&\n      request.__experimental_cacheKey\n    ) {\n      logger.debug(\"Saving cached docs...\");\n      try {\n        await saveCachedDocs(\n          [...docsMap.values()],\n          request.__experimental_cacheKey,\n        );\n      } catch (error) {\n        logger.error(\"Error saving cached docs\", { error });\n      }\n    }\n\n    // fs.writeFile(\n    //   `logs/${request.urls?.[0].replaceAll(\"https://\", \"\").replaceAll(\"http://\", \"\").replaceAll(\"/\", \"-\").replaceAll(\".\", \"-\")}-extract-${extractId}.json`,\n    //   JSON.stringify(log, null, 2),\n    // );\n\n    return {\n      success: true,\n      data: finalResult ?? {},\n      extractId,\n      warning: undefined,\n      urlTrace: request.urlTrace ? urlTraces : undefined,\n      llmUsage,\n      totalUrlsScraped,\n      sources,\n    };\n  } catch (error) {\n    const tokens_billed = 300 + calculateThinkingCost(costTracking);\n    await billTeam(teamId, subId, tokens_billed, logger, true).catch((error) => {\n      logger.error(\n        `Failed to bill team ${teamId} for thinking tokens: ${error}`,\n      );\n    });\n    await logJob({\n      job_id: extractId,\n      success: false,\n      message: (error instanceof Error ? error.message : typeof error === \"string\" ? error : \"An unexpected error occurred\"),\n      num_docs: 1,\n      docs: [],\n      time_taken: (new Date().getTime() - Date.now()) / 1000,\n      team_id: teamId,\n      mode: \"extract\",\n      url: request.urls?.join(\", \") || \"\",\n      scrapeOptions: request,\n      origin: request.origin ?? \"api\",\n      integration: request.integration,\n      num_tokens: 0,\n      tokens_billed,\n      sources,\n      cost_tracking: costTracking,\n      zeroDataRetention: false, // not supported\n    });\n    \n    throw error;\n  }\n}\n"]}