{"version":3,"file":"source-tracker.test.js","sourceRoot":"","sources":["../../../../../../src/lib/extract/helpers/__tests__/source-tracker.test.ts"],"names":[],"mappings":"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","sourcesContent":["import { SourceTracker } from \"../source-tracker\";\nimport { transformArrayToObject } from \"../transform-array-to-obj\";\n\ndescribe(\"SourceTracker\", () => {\n  let sourceTracker: SourceTracker;\n\n  beforeEach(() => {\n    sourceTracker = new SourceTracker();\n  });\n\n  describe(\"transformResults\", () => {\n    it(\"should transform and merge results while preserving sources\", () => {\n      const extractionResults = [\n        {\n          extract: { products: [{ name: \"Product 1\", price: 10 }] },\n          url: \"http://example1.com\"\n        },\n        {\n          extract: { products: [{ name: \"Product 2\", price: 20 }] },\n          url: \"http://example2.com\"\n        }\n      ];\n\n      const schema = {\n        type: \"object\",\n        properties: {\n          products: {\n            type: \"array\",\n            items: {\n              type: \"object\",\n              properties: {\n                name: { type: \"string\" },\n                price: { type: \"number\" }\n              }\n            }\n          }\n        }\n      };\n\n      const result = sourceTracker.transformResults(extractionResults, schema);\n      expect(result).toEqual({\n        products: [\n          { name: \"Product 1\", price: 10 },\n          { name: \"Product 2\", price: 20 }\n        ]\n      });\n    });\n\n    it(\"should match original transformArrayToObject behavior\", () => {\n      // Test case 1: Simple array transformation\n      const schema1 = {\n        type: \"object\",\n        properties: {\n          items: {\n            type: \"array\",\n            items: {\n              type: \"object\",\n              properties: {\n                id: { type: \"number\" }\n              }\n            }\n          }\n        }\n      };\n\n      const extractionResults1 = [\n        { extract: { items: [{ id: 1 }] }, url: \"url1\" },\n        { extract: { items: [{ id: 2 }] }, url: \"url2\" }\n      ];\n\n      const originalResult1 = transformArrayToObject(schema1, extractionResults1.map(r => r.extract));\n      const newResult1 = sourceTracker.transformResults(extractionResults1, schema1);\n      expect(newResult1).toEqual(originalResult1);\n\n      // Test case 2: Nested objects with arrays\n      const schema2 = {\n        type: \"object\",\n        properties: {\n          data: {\n            type: \"object\",\n            properties: {\n              products: {\n                type: \"array\",\n                items: {\n                  type: \"object\",\n                  properties: {\n                    id: { type: \"number\" },\n                    variants: {\n                      type: \"array\",\n                      items: { type: \"string\" }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      };\n\n      const extractionResults2 = [\n        {\n          extract: {\n            data: {\n              products: [\n                { id: 1, variants: [\"a\", \"b\"] }\n              ]\n            }\n          },\n          url: \"url1\"\n        },\n        {\n          extract: {\n            data: {\n              products: [\n                { id: 2, variants: [\"c\", \"d\"] }\n              ]\n            }\n          },\n          url: \"url2\"\n        }\n      ];\n\n      const originalResult2 = transformArrayToObject(schema2, extractionResults2.map(r => r.extract));\n      const newResult2 = sourceTracker.transformResults(extractionResults2, schema2);\n      expect(newResult2).toEqual(originalResult2);\n\n      // Test case 3: Empty arrays\n      const emptyResults = [];\n      const originalResult3 = transformArrayToObject(schema1, emptyResults);\n      const newResult3 = sourceTracker.transformResults([], schema1);\n      expect(newResult3).toEqual(originalResult3);\n\n      // Test case 4: Non-array properties\n      const schema4 = {\n        type: \"object\",\n        properties: {\n          name: { type: \"string\" },\n          count: { type: \"number\" }\n        }\n      };\n\n      const extractionResults4 = [\n        { extract: { name: \"test1\", count: 1 }, url: \"url1\" },\n        { extract: { name: \"test2\", count: 2 }, url: \"url2\" }\n      ];\n\n      const originalResult4 = transformArrayToObject(schema4, extractionResults4.map(r => r.extract));\n      const newResult4 = sourceTracker.transformResults(extractionResults4, schema4);\n      expect(newResult4).toEqual(originalResult4);\n    });\n  });\n\n  describe(\"mapSourcesToFinalItems\", () => {\n    it(\"should correctly map sources after deduplication and merging\", () => {\n      // Setup initial data with mergeable items (same name, complementary fields)\n      const extractionResults = [\n        {\n          extract: { products: [{ name: \"Product 1\", price: 10, description: null }] },\n          url: \"http://example1.com\"\n        },\n        {\n          extract: { products: [{ name: \"Product 1\", price: null, description: \"Great product\" }] },\n          url: \"http://example2.com\"\n        }\n      ];\n\n      const schema = {\n        type: \"object\",\n        properties: {\n          products: {\n            type: \"array\",\n            items: {\n              type: \"object\",\n              properties: {\n                name: { type: \"string\" },\n                price: { type: \"number\" },\n                description: { type: \"string\" }\n              }\n            }\n          }\n        }\n      };\n\n      // Transform results first\n      const multiEntityResult = sourceTracker.transformResults(extractionResults, schema);\n      sourceTracker.trackPreDeduplicationSources(multiEntityResult);\n\n      // Test source mapping with a merged item that matches both sources\n      const sources = sourceTracker.mapSourcesToFinalItems(\n        {\n          products: [\n            { name: \"Product 1\", price: 10, description: \"Great product\" }\n          ]\n        },\n        [\"products\"]\n      );\n\n      expect(sources).toEqual({\n        \"products[0]\": [\"http://example1.com\", \"http://example2.com\"]\n      });\n    });\n\n    it(\"should handle empty results\", () => {\n      const sources = sourceTracker.mapSourcesToFinalItems({}, []);\n      expect(sources).toEqual({});\n    });\n\n    it(\"should handle non-array properties\", () => {\n      const sources = sourceTracker.mapSourcesToFinalItems(\n        { nonArray: \"value\" } as any,\n        [\"nonArray\"]\n      );\n      expect(sources).toEqual({});\n    });\n  });\n\n  describe(\"trackPreDeduplicationSources\", () => {\n    it(\"should track sources before deduplication\", () => {\n      const extractionResults = [\n        {\n          extract: { products: [{ id: 1, name: \"Product 1\" }] },\n          url: \"http://example1.com\"\n        },\n        {\n          extract: { products: [{ id: 1, name: \"Product 1\" }] },\n          url: \"http://example2.com\"\n        }\n      ];\n\n      const schema = {\n        type: \"object\",\n        properties: {\n          products: {\n            type: \"array\",\n            items: {\n              type: \"object\",\n              properties: {\n                id: { type: \"number\" },\n                name: { type: \"string\" }\n              }\n            }\n          }\n        }\n      };\n\n      const multiEntityResult = sourceTracker.transformResults(extractionResults, schema);\n      sourceTracker.trackPreDeduplicationSources(multiEntityResult);\n\n      // Test source mapping after deduplication\n      const sources = sourceTracker.mapSourcesToFinalItems(\n        {\n          products: [{ id: 1, name: \"Product 1\" }]\n        },\n        [\"products\"]\n      );\n\n      expect(sources).toEqual({\n        \"products[0]\": [\"http://example1.com\", \"http://example2.com\"]\n      });\n    });\n  });\n}); "]}