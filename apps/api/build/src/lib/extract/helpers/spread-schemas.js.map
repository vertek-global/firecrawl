{"version":3,"file":"spread-schemas.js","sourceRoot":"","sources":["../../../../../src/lib/extract/helpers/spread-schemas.ts"],"names":[],"mappings":";;AAEA,sCAiFC;AAjFM,KAAK,UAAU,aAAa,CACjC,MAAW,EACX,IAAc;IAKd,IAAI,kBAAkB,GAAG,EAAE,GAAG,MAAM,EAAE,UAAU,EAAE,EAAE,GAAG,MAAM,CAAC,UAAU,EAAE,EAAE,CAAC;IAC7E,IAAI,iBAAiB,GAAQ;QAC3B,IAAI,EAAE,QAAQ;QACd,UAAU,EAAE,EAAE;QACd,GAAG,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,QAAQ,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC;KAC7C,CAAC;IAEF,+DAA+D;IAC/D,MAAM,eAAe,GAAG,CAAC,MAAW,EAAE,IAAc,EAAW,EAAE;QAC/D,IAAI,OAAO,GAAG,MAAM,CAAC,UAAU,CAAC;QAChC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YACrC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;gBAAE,OAAO,KAAK,CAAC;YACpC,IAAI,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,OAAO,IAAI,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC;gBAChE,OAAO,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,UAAU,CAAC;YAC9C,CAAC;iBAAM,CAAC;gBACN,OAAO,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC;YACxC,CAAC;QACH,CAAC;QACD,OAAO,IAAI,CAAC;IACd,CAAC,CAAC;IAEF,yDAAyD;IACzD,MAAM,eAAe,GAAG,CAAC,IAAY,EAAU,EAAE;QAC/C,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;IAC5B,CAAC,CAAC;IAEF,IAAI,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,EAAE;QACnB,MAAM,YAAY,GAAG,eAAe,CAAC,GAAG,CAAC,CAAC;QAC1C,IAAI,kBAAkB,CAAC,UAAU,CAAC,YAAY,CAAC,EAAE,CAAC;YAChD,iBAAiB,CAAC,UAAU,CAAC,YAAY,CAAC,GAAG,kBAAkB,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC;YACzF,OAAO,kBAAkB,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC;YAEnD,mCAAmC;YACnC,IAAI,MAAM,CAAC,QAAQ,EAAE,QAAQ,CAAC,YAAY,CAAC,EAAE,CAAC;gBAC5C,iBAAiB,CAAC,QAAQ,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;gBAC9C,kBAAkB,CAAC,QAAQ,GAAG,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAS,EAAE,EAAE,CAAC,CAAC,KAAK,YAAY,CAAC,CAAC;YAC1F,CAAC;QACH,CAAC;IACH,CAAC,CAAC,CAAC;IAEH,4DAA4D;IAC5D,MAAM,qBAAqB,GAAG,CAAC,MAAW,EAAE,EAAE;QAC5C,KAAK,MAAM,GAAG,IAAI,MAAM,CAAC,UAAU,EAAE,CAAC;YACpC,IACE,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,UAAU;gBACjC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,UAAU,CAAC,CAAC,MAAM,KAAK,CAAC,EAC3D,CAAC;gBACD,OAAO,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;YAChC,CAAC;iBAAM,IAAI,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,UAAU,EAAE,CAAC;gBAC7C,qBAAqB,CAAC,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC;YAChD,CAAC;QACH,CAAC;IACH,CAAC,CAAC;IAEF,qBAAqB,CAAC,kBAAkB,CAAC,CAAC;IAC1C,qBAAqB,CAAC,iBAAiB,CAAC,CAAC;IAEzC,uEAAuE;IACvE,IAAI,MAAM,CAAC,IAAI,CAAC,kBAAkB,CAAC,UAAU,CAAC,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QAC5D,kBAAkB,GAAG,EAAE,CAAC;IAC1B,CAAC;SAAM,IAAI,kBAAkB,CAAC,QAAQ,EAAE,MAAM,KAAK,CAAC,EAAE,CAAC;QACrD,OAAO,kBAAkB,CAAC,QAAQ,CAAC;IACrC,CAAC;IAED,IAAI,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC,UAAU,CAAC,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QAC3D,iBAAiB,GAAG,EAAE,CAAC;IACzB,CAAC;SAAM,IAAI,iBAAiB,CAAC,QAAQ,EAAE,MAAM,KAAK,CAAC,EAAE,CAAC;QACpD,OAAO,iBAAiB,CAAC,QAAQ,CAAC;IACpC,CAAC;IAED,OAAO;QACL,kBAAkB;QAClB,iBAAiB;KAClB,CAAC;AACJ,CAAC","sourcesContent":["import { logger } from \"../../../lib/logger\";\n\nexport async function spreadSchemas(\n  schema: any,\n  keys: string[],\n): Promise<{\n  singleAnswerSchema: any;\n  multiEntitySchema: any;\n}> {\n  let singleAnswerSchema = { ...schema, properties: { ...schema.properties } };\n  let multiEntitySchema: any = { \n    type: \"object\", \n    properties: {},\n    ...(schema.required ? { required: [] } : {})\n  };\n\n  // Helper function to check if a property path exists in schema\n  const hasPropertyPath = (schema: any, path: string[]): boolean => {\n    let current = schema.properties;\n    for (let i = 0; i < path.length; i++) {\n      if (!current[path[i]]) return false;\n      if (current[path[i]].type === \"array\" && current[path[i]].items) {\n        current = current[path[i]].items.properties;\n      } else {\n        current = current[path[i]].properties;\n      }\n    }\n    return true;\n  };\n\n  // Helper function to get the root property of a dot path\n  const getRootProperty = (path: string): string => {\n    return path.split('.')[0];\n  };\n\n  keys.forEach((key) => {\n    const rootProperty = getRootProperty(key);\n    if (singleAnswerSchema.properties[rootProperty]) {\n      multiEntitySchema.properties[rootProperty] = singleAnswerSchema.properties[rootProperty];\n      delete singleAnswerSchema.properties[rootProperty];\n      \n      // Move required field if it exists\n      if (schema.required?.includes(rootProperty)) {\n        multiEntitySchema.required.push(rootProperty);\n        singleAnswerSchema.required = schema.required.filter((k: string) => k !== rootProperty);\n      }\n    }\n  });\n\n  // Recursively delete empty properties in singleAnswerSchema\n  const deleteEmptyProperties = (schema: any) => {\n    for (const key in schema.properties) {\n      if (\n        schema.properties[key].properties &&\n        Object.keys(schema.properties[key].properties).length === 0\n      ) {\n        delete schema.properties[key];\n      } else if (schema.properties[key].properties) {\n        deleteEmptyProperties(schema.properties[key]);\n      }\n    }\n  };\n\n  deleteEmptyProperties(singleAnswerSchema);\n  deleteEmptyProperties(multiEntitySchema);\n\n  // If singleAnswerSchema has no properties left, return an empty object\n  if (Object.keys(singleAnswerSchema.properties).length === 0) {\n    singleAnswerSchema = {};\n  } else if (singleAnswerSchema.required?.length === 0) {\n    delete singleAnswerSchema.required;\n  }\n\n  if (Object.keys(multiEntitySchema.properties).length === 0) {\n    multiEntitySchema = {};\n  } else if (multiEntitySchema.required?.length === 0) {\n    delete multiEntitySchema.required;\n  }\n\n  return {\n    singleAnswerSchema,\n    multiEntitySchema,\n  };\n}\n"]}