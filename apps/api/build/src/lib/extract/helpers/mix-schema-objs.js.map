{"version":3,"file":"mix-schema-objs.js","sourceRoot":"","sources":["../../../../../src/lib/extract/helpers/mix-schema-objs.ts"],"names":[],"mappings":";;AAEA,4CA6CC;AA7CM,KAAK,UAAU,gBAAgB,CACpC,WAAgB,EAChB,kBAAuB,EACvB,iBAAsB,EACtB,MAAe;IAEf,MAAM,WAAW,GAAQ,EAAE,CAAC;IAC5B,MAAM,EAAE,KAAK,CAAC,wBAAwB,CAAC,CAAC;IAExC,6DAA6D;IAC7D,SAAS,YAAY,CAAC,MAAW,EAAE,YAAiB,EAAE,WAAgB;QACpE,MAAM,MAAM,GAAQ,EAAE,CAAC;QACvB,KAAK,MAAM,GAAG,IAAI,MAAM,CAAC,UAAU,EAAE,CAAC;YACpC,IACE,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,IAAI,KAAK,QAAQ;gBACxC,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,UAAU,EACjC,CAAC;gBACD,iEAAiE;gBACjE,MAAM,CAAC,GAAG,CAAC,GAAG,YAAY,CACxB,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,EACtB,YAAY,CAAC,GAAG,CAAC,IAAI,EAAE,EACvB,WAAW,CAAC,GAAG,CAAC,IAAI,EAAE,CACvB,CAAC;YACJ,CAAC;iBAAM,IACL,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,IAAI,KAAK,OAAO;gBACvC,KAAK,CAAC,OAAO,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,EAC/B,CAAC;gBACD,mEAAmE;gBACnE,MAAM,CAAC,GAAG,CAAC,GAAG,WAAW,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,CAAC;YACxC,CAAC;iBAAM,IAAI,YAAY,CAAC,cAAc,CAAC,GAAG,CAAC,EAAE,CAAC;gBAC5C,MAAM,CAAC,GAAG,CAAC,GAAG,YAAY,CAAC,GAAG,CAAC,CAAC;YAClC,CAAC;iBAAM,IAAI,WAAW,CAAC,cAAc,CAAC,GAAG,CAAC,EAAE,CAAC;gBAC3C,MAAM,CAAC,GAAG,CAAC,GAAG,WAAW,CAAC,GAAG,CAAC,CAAC;YACjC,CAAC;QACH,CAAC;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;IAED,6CAA6C;IAC7C,MAAM,CAAC,MAAM,CACX,WAAW,EACX,YAAY,CAAC,WAAW,EAAE,kBAAkB,EAAE,iBAAiB,CAAC,CACjE,CAAC;IAEF,OAAO,WAAW,CAAC;AACrB,CAAC","sourcesContent":["import type { Logger } from \"winston\";\n\nexport async function mixSchemaObjects(\n  finalSchema: any,\n  singleAnswerResult: any,\n  multiEntityResult: any,\n  logger?: Logger\n) {\n  const finalResult: any = {};\n  logger?.debug(\"Mixing schema objects.\");\n\n  // Recursive helper function to merge results based on schema\n  function mergeResults(schema: any, singleResult: any, multiResult: any) {\n    const result: any = {};\n    for (const key in schema.properties) {\n      if (\n        schema.properties[key].type === \"object\" &&\n        schema.properties[key].properties\n      ) {\n        // If the property is an object, recursively merge its properties\n        result[key] = mergeResults(\n          schema.properties[key],\n          singleResult[key] || {},\n          multiResult[key] || {},\n        );\n      } else if (\n        schema.properties[key].type === \"array\" &&\n        Array.isArray(multiResult[key])\n      ) {\n        // If the property is an array, flatten the arrays from multiResult\n        result[key] = multiResult[key].flat();\n      } else if (singleResult.hasOwnProperty(key)) {\n        result[key] = singleResult[key];\n      } else if (multiResult.hasOwnProperty(key)) {\n        result[key] = multiResult[key];\n      }\n    }\n    return result;\n  }\n\n  // Merge the properties from the final schema\n  Object.assign(\n    finalResult,\n    mergeResults(finalSchema, singleAnswerResult, multiEntityResult),\n  );\n\n  return finalResult;\n}\n"]}