{"version":3,"file":"reranker-f0.js","sourceRoot":"","sources":["../../../../../src/lib/extract/fire-0/reranker-f0.ts"],"names":[],"mappings":"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","sourcesContent":["import { MapDocument, TeamFlags, URLTrace } from \"../../../controllers/v1/types\";\nimport { isUrlBlocked } from \"../../../scraper/WebScraper/utils/blocklist\";\nimport { logger } from \"../../logger\";\nimport { CohereClient } from \"cohere-ai\";\nimport { extractConfig } from \"../config\";\nimport { generateCompletions } from \"../../../scraper/scrapeURL/transformers/llmExtract\";\nimport { performRanking_F0 } from \"./ranker-f0\";\nimport { buildRerankerSystemPrompt_F0, buildRerankerUserPrompt_F0 } from \"./build-prompts-f0\";\nimport { CostTracking } from \"../extraction-service\";\nconst cohere = new CohereClient({\n  token: process.env.COHERE_API_KEY,\n});\n\ninterface RankingResult {\n  mappedLinks: MapDocument[];\n  linksAndScores: {\n    link: string;\n    linkWithContext: string;\n    score: number;\n    originalIndex: number;\n  }[];\n}\n\nexport async function rerankDocuments_FO(\n  documents: (string | Record<string, string>)[],\n  query: string,\n  topN = 3,\n  model = \"rerank-english-v3.0\",\n) {\n  const rerank = await cohere.v2.rerank({\n    documents,\n    query,\n    topN,\n    model,\n    returnDocuments: true,\n  });\n\n  return rerank.results\n    .sort((a, b) => b.relevanceScore - a.relevanceScore)\n    .map((x) => ({\n      document: x.document,\n      index: x.index,\n      relevanceScore: x.relevanceScore,\n    }));\n}\n\nexport async function rerankLinks_F0(\n  mappedLinks: MapDocument[],\n  searchQuery: string,\n  urlTraces: URLTrace[],\n  flags: TeamFlags,\n): Promise<MapDocument[]> {\n  // console.log(\"Going to rerank links\");\n  const mappedLinksRerank = mappedLinks.map(\n    (x) => `url: ${x.url}, title: ${x.title}, description: ${x.description}`,\n  );\n\n  const linksAndScores = await performRanking_F0(\n    mappedLinksRerank,\n    mappedLinks.map((l) => l.url),\n    searchQuery,\n  );\n\n  // First try with high threshold\n  let filteredLinks = filterAndProcessLinks_F0(\n    mappedLinks,\n    linksAndScores,\n    extractConfig.RERANKING.INITIAL_SCORE_THRESHOLD_FOR_RELEVANCE,\n    flags,\n  );\n\n  // If we don't have enough high-quality links, try with lower threshold\n  if (filteredLinks.length < extractConfig.RERANKING.MIN_REQUIRED_LINKS) {\n    logger.info(\n      `Only found ${filteredLinks.length} links with score > ${extractConfig.RERANKING.INITIAL_SCORE_THRESHOLD_FOR_RELEVANCE}. Trying lower threshold...`,\n    );\n    filteredLinks = filterAndProcessLinks_F0(\n      mappedLinks,\n      linksAndScores,\n      extractConfig.RERANKING.FALLBACK_SCORE_THRESHOLD_FOR_RELEVANCE,\n      flags,\n    );\n\n    if (filteredLinks.length === 0) {\n      // If still no results, take top N results regardless of score\n      logger.warn(\n        `No links found with score > ${extractConfig.RERANKING.FALLBACK_SCORE_THRESHOLD_FOR_RELEVANCE}. Taking top ${extractConfig.RERANKING.MIN_REQUIRED_LINKS} results.`,\n      );\n      filteredLinks = linksAndScores\n        .sort((a, b) => b.score - a.score)\n        .slice(0, extractConfig.RERANKING.MIN_REQUIRED_LINKS)\n        .map((x) => mappedLinks.find((link) => link.url === x.link))\n        .filter(\n          (x): x is MapDocument =>\n            x !== undefined && x.url !== undefined && !isUrlBlocked(x.url, flags),\n        );\n    }\n  }\n\n  // Update URL traces with relevance scores and mark filtered out URLs\n  linksAndScores.forEach((score) => {\n    const trace = urlTraces.find((t) => t.url === score.link);\n    if (trace) {\n      trace.relevanceScore = score.score;\n      // If URL didn't make it through filtering, mark it as filtered out\n      if (!filteredLinks.some((link) => link.url === score.link)) {\n        trace.warning = `Relevance score ${score.score} below threshold`;\n        trace.usedInCompletion = false;\n      }\n    }\n  });\n\n  const rankedLinks = filteredLinks.slice(\n    0,\n    extractConfig.RERANKING.MAX_RANKING_LIMIT_FOR_RELEVANCE,\n  );\n\n  // Mark URLs that will be used in completion\n  rankedLinks.forEach((link) => {\n    const trace = urlTraces.find((t) => t.url === link.url);\n    if (trace) {\n      trace.usedInCompletion = true;\n    }\n  });\n\n  // Mark URLs that were dropped due to ranking limit\n  filteredLinks\n    .slice(extractConfig.RERANKING.MAX_RANKING_LIMIT_FOR_RELEVANCE)\n    .forEach((link) => {\n      const trace = urlTraces.find((t) => t.url === link.url);\n      if (trace) {\n        trace.warning = \"Excluded due to ranking limit\";\n        trace.usedInCompletion = false;\n      }\n    });\n\n  // console.log(\"Reranked links: \", rankedLinks.length);\n\n  return rankedLinks;\n}\n\nfunction filterAndProcessLinks_F0(\n  mappedLinks: MapDocument[],\n  linksAndScores: {\n    link: string;\n    linkWithContext: string;\n    score: number;\n    originalIndex: number;\n  }[],\n  threshold: number,\n  flags: TeamFlags,\n): MapDocument[] {\n  return linksAndScores\n    .filter((x) => x.score > threshold)\n    .map((x) => mappedLinks.find((link) => link.url === x.link))\n    .filter(\n      (x): x is MapDocument =>\n        x !== undefined && x.url !== undefined && !isUrlBlocked(x.url, flags),\n    );\n}\n\nexport type RerankerResult = {\n  mapDocument: (MapDocument & { relevanceScore?: number; reason?: string })[];\n  tokensUsed: number;\n};\n\nexport type RerankerOptions = {\n  links: MapDocument[];\n  searchQuery: string;\n  urlTraces: URLTrace[];\n};\n\nexport async function rerankLinksWithLLM_F0(options: RerankerOptions, costTracking: CostTracking): Promise<RerankerResult> {\n  const { links, searchQuery, urlTraces } = options;\n  const chunkSize = 100;\n  const chunks: MapDocument[][] = [];\n  const TIMEOUT_MS = 20000;\n  const MAX_RETRIES = 2;\n  let totalTokensUsed = 0;\n\n  // Split links into chunks of 200\n  for (let i = 0; i < links.length; i += chunkSize) {\n    chunks.push(links.slice(i, i + chunkSize));\n  }\n\n  // console.log(`Total links: ${mappedLinks.length}, Number of chunks: ${chunks.length}`);\n\n  const schema = {\n    type: \"object\",\n    properties: {\n      relevantLinks: {\n        type: \"array\",\n        items: {\n          type: \"object\",\n          properties: {\n            url: { type: \"string\" },\n            relevanceScore: { type: \"number\" },\n            reason: { type: \"string\", description: \"The reason why you chose the score for this link given the intent.\" },\n          },\n          required: [\"url\", \"relevanceScore\", \"reason\"],\n        },\n      },\n    },\n    required: [\"relevantLinks\"],\n  };\n\n  const results = await Promise.all(\n    chunks.map(async (chunk, chunkIndex) => {\n      // console.log(`Processing chunk ${chunkIndex + 1}/${chunks.length} with ${chunk.length} links`);\n\n      const linksContent = chunk\n        .map(\n          (link) =>\n            `URL: ${link.url}${link.title ? `\\nTitle: ${link.title}` : \"\"}${link.description ? `\\nDescription: ${link.description}` : \"\"}`,\n        )\n        .join(\"\\n\\n\");\n\n      for (let retry = 0; retry <= MAX_RETRIES; retry++) {\n        try {\n          const timeoutPromise = new Promise<null>((resolve) => {\n            setTimeout(() => resolve(null), TIMEOUT_MS);\n          });\n\n          // dumpToFile(new Date().toISOString(),[buildRerankerSystemPrompt(), buildRerankerUserPrompt(searchQuery), schema, linksContent])\n          const completionPromise = generateCompletions({\n            logger: logger.child({\n              method: \"rerankLinksWithLLM\",\n              chunk: chunkIndex + 1,\n              retry,\n            }),\n            options: {\n              mode: \"llm\",\n              systemPrompt: buildRerankerSystemPrompt_F0(),\n              prompt: buildRerankerUserPrompt_F0(searchQuery),\n              schema: schema,\n            },\n            markdown: linksContent,\n            isExtractEndpoint: true,\n            costTrackingOptions: {\n              costTracking: new CostTracking(),\n              metadata: {\n                module: \"extract\",\n                method: \"rerankLinksWithLLM\",\n              },\n            },\n          });\n\n          const completion = await Promise.race([\n            completionPromise,\n            timeoutPromise,\n          ]);\n\n          if (!completion) {\n            // console.log(`Chunk ${chunkIndex + 1}: Timeout on attempt ${retry + 1}`);\n            continue;\n          }\n\n          if (!completion.extract?.relevantLinks) {\n            // console.warn(`Chunk ${chunkIndex + 1}: No relevant links found in completion response`);\n            return [];\n          }\n\n          totalTokensUsed += completion.numTokens || 0;\n          // console.log(`Chunk ${chunkIndex + 1}: Found ${completion.extract.relevantLinks.length} relevant links`);\n          return completion.extract.relevantLinks;\n        } catch (error) {\n          console.warn(\n            `Error processing chunk ${chunkIndex + 1} attempt ${retry + 1}:`,\n            error,\n          );\n          if (retry === MAX_RETRIES) {\n            // console.log(`Chunk ${chunkIndex + 1}: Max retries reached, returning empty array`);\n            return [];\n          }\n        }\n      }\n      return [];\n    }),\n  );\n\n  // console.log(`Processed ${results.length} chunks`);\n\n  // Flatten results and sort by relevance score\n  const flattenedResults = results\n    .flat()\n    .sort((a, b) => b.relevanceScore - a.relevanceScore);\n  // console.log(`Total relevant links found: ${flattenedResults.length}`);\n\n  // Map back to MapDocument format, keeping only relevant links\n  const relevantLinks = flattenedResults\n    .map((result) => {\n      const link = links.find((link) => link.url === result.url);\n      if (link) {\n        return { ...link, relevanceScore: result.relevanceScore ? parseFloat(result.relevanceScore) : 0, reason: result.reason };\n      }\n      return undefined;\n    })\n    .filter((link): link is NonNullable<typeof link> => link !== undefined);\n\n  return {\n    mapDocument: relevantLinks,\n    tokensUsed: totalTokensUsed,\n  };\n}\n"]}