{"version":3,"file":"html-to-markdown.test.js","sourceRoot":"","sources":["../../../../src/lib/__tests__/html-to-markdown.test.ts"],"names":[],"mappings":";;AAAA,0DAAoD;AAEpD,QAAQ,CAAC,eAAe,EAAE,GAAG,EAAE;IAC7B,EAAE,CAAC,kDAAkD,EAAE,KAAK,IAAI,EAAE;QAChE,MAAM,IAAI,GAAG,sBAAsB,CAAC;QACpC,MAAM,gBAAgB,GAAG,eAAe,CAAC;QACzC,MAAM,MAAM,CAAC,IAAA,gCAAa,EAAC,IAAI,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;IACpE,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,8DAA8D,EAAE,KAAK,IAAI,EAAE;QAC5E,MAAM,IAAI,GACR,iFAAiF,CAAC;QACpF,MAAM,gBAAgB,GAAG,sCAAsC,CAAC;QAChE,MAAM,MAAM,CAAC,IAAA,gCAAa,EAAC,IAAI,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;IACpE,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,gDAAgD,EAAE,KAAK,IAAI,EAAE;QAC9D,MAAM,IAAI,GAAG,EAAE,CAAC;QAChB,MAAM,gBAAgB,GAAG,EAAE,CAAC;QAC5B,MAAM,MAAM,CAAC,IAAA,gCAAa,EAAC,IAAI,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;IACpE,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,qCAAqC,EAAE,KAAK,IAAI,EAAE;QACnD,MAAM,IAAI,GAAG,IAAI,CAAC;QAClB,MAAM,gBAAgB,GAAG,EAAE,CAAC;QAC5B,MAAM,MAAM,CAAC,IAAA,gCAAa,EAAC,IAAI,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;IACpE,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,wDAAwD,EAAE,KAAK,IAAI,EAAE;QACtE,MAAM,YAAY,GAAG;YACnB,EAAE,IAAI,EAAE,uBAAuB,EAAE,QAAQ,EAAE,cAAc,EAAE;YAC3D;gBACE,IAAI,EAAE,gCAAgC;gBACtC,QAAQ,EAAE,qBAAqB;aAChC;YACD;gBACE,IAAI,EAAE,4CAA4C;gBAClD,QAAQ,EAAE,mBAAmB;aAC9B;YACD;gBACE,IAAI,EAAE,uDAAuD;gBAC7D,QAAQ,EAAE,gDAAgD;aAC3D;SACF,CAAC;QAEF,KAAK,MAAM,EAAE,IAAI,EAAE,QAAQ,EAAE,IAAI,YAAY,EAAE,CAAC;YAC9C,MAAM,MAAM,CAAC,IAAA,gCAAa,EAAC,IAAI,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAC5D,CAAC;IACH,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC","sourcesContent":["import { parseMarkdown } from \"../html-to-markdown\";\n\ndescribe(\"parseMarkdown\", () => {\n  it(\"should correctly convert simple HTML to Markdown\", async () => {\n    const html = \"<p>Hello, world!</p>\";\n    const expectedMarkdown = \"Hello, world!\";\n    await expect(parseMarkdown(html)).resolves.toBe(expectedMarkdown);\n  });\n\n  it(\"should convert complex HTML with nested elements to Markdown\", async () => {\n    const html =\n      \"<div><p>Hello <strong>bold</strong> world!</p><ul><li>List item</li></ul></div>\";\n    const expectedMarkdown = \"Hello **bold** world!\\n\\n- List item\";\n    await expect(parseMarkdown(html)).resolves.toBe(expectedMarkdown);\n  });\n\n  it(\"should return empty string when input is empty\", async () => {\n    const html = \"\";\n    const expectedMarkdown = \"\";\n    await expect(parseMarkdown(html)).resolves.toBe(expectedMarkdown);\n  });\n\n  it(\"should handle null input gracefully\", async () => {\n    const html = null;\n    const expectedMarkdown = \"\";\n    await expect(parseMarkdown(html)).resolves.toBe(expectedMarkdown);\n  });\n\n  it(\"should handle various types of invalid HTML gracefully\", async () => {\n    const invalidHtmls = [\n      { html: \"<html><p>Unclosed tag\", expected: \"Unclosed tag\" },\n      {\n        html: \"<div><span>Missing closing div\",\n        expected: \"Missing closing div\",\n      },\n      {\n        html: \"<p><strong>Wrong nesting</em></strong></p>\",\n        expected: \"**Wrong nesting**\",\n      },\n      {\n        html: '<a href=\"http://example.com\">Link without closing tag',\n        expected: \"[Link without closing tag](http://example.com)\",\n      },\n    ];\n\n    for (const { html, expected } of invalidHtmls) {\n      await expect(parseMarkdown(html)).resolves.toBe(expected);\n    }\n  });\n});\n"]}