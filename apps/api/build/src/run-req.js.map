{"version":3,"file":"run-req.js","sourceRoot":"","sources":["../../src/run-req.ts"],"names":[],"mappings":"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","sourcesContent":["import axios from \"axios\";\nimport { promises as fs } from \"fs\";\nimport { v4 as uuidV4 } from \"uuid\";\n\ninterface Result {\n  start_url: string;\n  job_id?: string;\n  idempotency_key?: string;\n  result_data_jsonb?: any;\n}\n\nasync function sendCrawl(result: Result): Promise<string | undefined> {\n  const idempotencyKey = uuidV4();\n  const url = result.start_url;\n  try {\n    const response = await axios.post(\n      \"https://staging-firecrawl-scraper-js.fly.dev/v0/crawl\",\n      {\n        url: url,\n        crawlerOptions: {\n          limit: 75,\n        },\n        pageOptions: {\n          includeHtml: true,\n          replaceAllPathsWithAbsolutePaths: true,\n          waitFor: 1000,\n        },\n      },\n      {\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer `,\n        },\n      },\n    );\n    result.idempotency_key = idempotencyKey;\n    return response.data.jobId;\n  } catch (error) {\n    console.error(\"Error sending crawl:\", error);\n    return undefined;\n  }\n}\n\nasync function getContent(result: Result): Promise<boolean> {\n  let attempts = 0;\n  while (attempts < 120) {\n    // Reduce the number of attempts to speed up\n    try {\n      const response = await axios.get(\n        `https://staging-firecrawl-scraper-js.fly.dev/v0/crawl/status/${result.job_id}`,\n        {\n          headers: {\n            \"Content-Type\": \"application/json\",\n            Authorization: `Bearer `,\n          },\n        },\n      );\n      if (response.data.status === \"completed\") {\n        result.result_data_jsonb = response.data.data;\n        // Job actually completed\n        return true;\n      }\n    } catch (error) {\n      console.error(\"Error getting content:\", error);\n    }\n    const randomSleep = Math.floor(Math.random() * 15000) + 5000;\n    await new Promise((resolve) => setTimeout(resolve, randomSleep)); // Reduce sleep time to 1.5 seconds\n    attempts++;\n  }\n  // Set result as null if timed out\n  result.result_data_jsonb = null;\n  return false;\n}\n\nasync function processResults(results: Result[]): Promise<void> {\n  let processedCount = 0;\n  let starterCount = 0;\n  const queue: Result[] = [];\n  const processedUrls = new Set<string>();\n\n  // Initialize the queue with the first 1000 results\n  for (let i = 0; i < Math.min(100, results.length); i++) {\n    queue.push(results[i]);\n    processedUrls.add(results[i].start_url);\n  }\n\n  // Function to process a single result\n  const processSingleResult = async (result: Result) => {\n    const jobId = await sendCrawl(result);\n    if (jobId) {\n      console.log(`Job requested count: ${starterCount}`);\n      starterCount++;\n      result.job_id = jobId;\n      processedCount++;\n      // Save the result to the file\n      try {\n        // Save job id along with the start_url\n        const resultWithJobId = results.map((r) => ({\n          start_url: r.start_url,\n          job_id: r.job_id,\n        }));\n        await fs.writeFile(\n          \"results_with_job_id_4000_6000.json\",\n          JSON.stringify(resultWithJobId, null, 4),\n        );\n      } catch (error) {\n        console.error(\"Error writing to results_with_content.json:\", error);\n      }\n\n      // Add a new result to the queue if there are more results to process\n      // if (processedCount < results.length) {\n      //   for (let i = queue.length; i < results.length; i++) {\n      //     if (!processedUrls.has(results[i].start_url)) {\n      //       const nextResult = results[i];\n      //       console.log(\"Next result:\", nextResult.start_url);\n      //       queue.push(nextResult);\n      //       processedUrls.add(nextResult.start_url);\n      //       console.log(`Queue length: ${queue.length}`);\n      //       processSingleResult(nextResult);\n      //       break;\n      //     }\n      //   }\n      // }\n    }\n  };\n\n  // Start processing the initial queue concurrently\n  // for (let i = 0; i < queue.length; i++) {\n  //   processSingleResult(queue[i]);\n  //   if ((i + 1) % 500 === 0) {\n  //     console.log(`Processed ${i + 1} results, waiting for 1 minute before adding the next batch...`);\n  //     await new Promise(resolve => setTimeout(resolve, 60 * 1000)); // Wait for 1 minute\n  //   }\n  // }\n  // Start processing the initial queue concurrently\n  // await Promise.all(queue.map(result => processSingleResult(result)));\n  for (let i = 0; i < results.length; i += 100) {\n    const batch = results.slice(i, i + 100);\n    Promise.all(batch.map((result) => processSingleResult(result)))\n      .then(() => {\n        console.log(`Processed ${i + 100} results.`);\n      })\n      .catch((error) => {\n        console.error(`Error processing batch starting at index ${i}:`, error);\n      });\n    await new Promise((resolve) => setTimeout(resolve, 60 * 1000)); // Wait for 1 minute\n  }\n}\n\n// Example call\n\nasync function getStartUrls(): Promise<Result[]> {\n  try {\n    const data = await fs.readFile(\"starturls.json\", \"utf-8\");\n    return JSON.parse(data);\n  } catch (error) {\n    console.error(\"Error reading starturls.json:\", error);\n    return [];\n  }\n}\n\nasync function main() {\n  const results: Result[] = (await getStartUrls()).slice(3999, 6000);\n  // console.log(results.map((r) => r.start_url).slice(0, 3));\n\n  processResults(results)\n    .then(() => {\n      console.log(\"All results processed.\");\n    })\n    .catch((error) => {\n      console.error(\"Error processing results:\", error);\n    });\n}\n\nmain();\n"]}