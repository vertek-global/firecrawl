{"version":3,"file":"mock.js","sourceRoot":"","sources":["../../../../../src/scraper/scrapeURL/lib/mock.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA,4BAqBC;AAmBD,4BA2BC;AA1ED,gDAAkC;AAClC,2CAA6B;AAC7B,gDAAwD;AAExD,MAAM,gBAAgB,GAAG,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC;AAChF,MAAM,gBAAgB,GAAG,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,gCAAgC,CAAC,CAAC,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC;AAE9F,KAAK,UAAU,QAAQ,CAAC,OAAgB,EAAE,MAAe;IAC9D,IAAI,OAAO,CAAC,GAAG,CAAC,oBAAoB,KAAK,MAAM;QAAE,OAAO;IAExD,MAAM,EAAE,CAAC,KAAK,CAAC,gBAAgB,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;IAEtD,MAAM,QAAQ,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,GAAG,GAAG,MAAM,CAAC,UAAU,EAAE,GAAG,OAAO,CAAC;IAClE,MAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,gBAAgB,EAAE,QAAQ,CAAC,CAAC;IACvD,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;IAEtB,MAAM,EAAE,CAAC,SAAS,CAChB,QAAQ,EACR,IAAI,CAAC,SAAS,CACZ;QACE,IAAI,EAAE,IAAI,CAAC,GAAG,EAAE;QAChB,OAAO;QACP,MAAM;KACP,EACD,SAAS,EACT,CAAC,CACF,CACF,CAAC;AACJ,CAAC;AAmBM,KAAK,UAAU,QAAQ,CAC5B,IAAY,EACZ,SAAiB,eAAO;IAExB,IAAI,CAAC;QACH,MAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,gBAAgB,EAAE,IAAI,GAAG,OAAO,CAAC,CAAC;QAE7D,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,gBAAgB,EAAE,QAAQ,CAAC,CAAC;QAC3D,IAAI,CAAC,QAAQ,IAAI,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE,CAAC;YACxE,mBAAmB;YACnB,OAAO,IAAI,CAAC;QACd,CAAC;QAED,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC,QAAQ,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC,CAAC;QAC7D,OAAO;YACL,QAAQ,EAAE,IAAI;YACd,OAAO,EAAE,EAAE;SACZ,CAAC;IACJ,CAAC;IAAC,OAAO,KAAK,EAAE,CAAC;QACf,MAAM,CAAC,IAAI,CAAC,2BAA2B,EAAE;YACvC,IAAI;YACJ,MAAM,EAAE,gBAAgB;YACxB,MAAM,EAAE,UAAU;YAClB,KAAK;SACN,CAAC,CAAC;QACH,OAAO,IAAI,CAAC;IACd,CAAC;AACH,CAAC","sourcesContent":["import * as fs from \"fs/promises\";\nimport * as path from \"path\";\nimport { logger as _logger } from \"../../../lib/logger\";\nimport { Logger } from \"winston\";\nconst saveMocksDirPath = path.join(__dirname, \"../mocks/\").replace(\"dist/\", \"\");\nconst loadMocksDirPath = path.join(__dirname, \"../../../__tests__/snips/mocks\").replace(\"dist/\", \"\");\n\nexport async function saveMock(options: unknown, result: unknown) {\n  if (process.env.FIRECRAWL_SAVE_MOCKS !== \"true\") return;\n\n  await fs.mkdir(saveMocksDirPath, { recursive: true });\n\n  const fileName = Date.now() + \"-\" + crypto.randomUUID() + \".json\";\n  const filePath = path.join(saveMocksDirPath, fileName);\n  console.log(filePath);\n\n  await fs.writeFile(\n    filePath,\n    JSON.stringify(\n      {\n        time: Date.now(),\n        options,\n        result,\n      },\n      undefined,\n      4,\n    ),\n  );\n}\n\nexport type MockState = {\n  requests: {\n    time: number;\n    options: {\n      url: string;\n      method: string;\n      body?: any;\n      ignoreResponse: boolean;\n      ignoreFailure: boolean;\n      tryCount: number;\n      tryCooldown?: number;\n    };\n    result: any;\n  }[];\n  tracker: Record<string, number>;\n};\n\nexport async function loadMock(\n  name: string,\n  logger: Logger = _logger,\n): Promise<MockState | null> {\n  try {\n    const mockPath = path.join(loadMocksDirPath, name + \".json\");\n\n    const relative = path.relative(loadMocksDirPath, mockPath);\n    if (!relative || relative.startsWith(\"..\") || path.isAbsolute(relative)) {\n      // directory moving\n      return null;\n    }\n\n    const load = JSON.parse(await fs.readFile(mockPath, \"utf8\"));\n    return {\n      requests: load,\n      tracker: {},\n    };\n  } catch (error) {\n    logger.warn(\"Failed to load mock file!\", {\n      name,\n      module: \"scrapeURL:mock\",\n      method: \"loadMock\",\n      error,\n    });\n    return null;\n  }\n}\n"]}