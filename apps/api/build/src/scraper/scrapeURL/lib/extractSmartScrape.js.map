{"version":3,"file":"extractSmartScrape.js","sourceRoot":"","sources":["../../../../../src/scraper/scrapeURL/lib/extractSmartScrape.ts"],"names":[],"mappings":"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","sourcesContent":["import { Logger } from \"winston\";\nimport { z } from \"zod\";\nimport {\n  generateCompletions,\n  GenerateCompletionsOptions,\n  generateSchemaFromPrompt,\n} from \"../transformers/llmExtract\";\nimport { smartScrape } from \"./smartScrape\";\nimport { parseMarkdown } from \"../../../lib/html-to-markdown\";\nimport { getModel } from \"../../../lib/generic-ai\";\nimport { TokenUsage } from \"../../../controllers/v1/types\";\nimport type { SmartScrapeResult } from \"./smartScrape\";\nimport { CostLimitExceededError, CostTracking } from \"../../../lib/extract/extraction-service\";\nconst commonSmartScrapeProperties = {\n  shouldUseSmartscrape: {\n    type: \"boolean\",\n    description:\n      \"Set to `true` if any of the extractedData is null and you think you can find the information by performing user-like interactions (e.g., clicking buttons/accordions to reveal hidden text, login, inputs, pagination etc.). SmartScrape can perform these actions to access the data.\",\n  },\n  // Note: extractedData is added dynamically in prepareSmartScrapeSchema\n};\n\n// Define common properties for reasoning and prompt\nconst commonReasoningPromptProperties = {\n  smartscrape_reasoning: {\n    type: [\"string\", \"null\"],\n    // Using the more detailed multi-step description as the common one\n    description:\n      \"Reasoning for why a SmartScrape is needed. Explain which data is missing or requires interaction.\",\n  },\n  smartscrape_prompt: {\n    type: [\"string\", \"null\"],\n    description: `A clear, outcome-focused prompt describing what information to find on the page. \n      Example: \"Find the product specifications in the expandable section\" rather than \"Click the button to reveal product specs\".\n      Used by the smart scraping agent to determine what actions to take.\n      Dont mention anything about extraction, smartscrape just returns page content.`,\n  },\n};\n\n// Schema for single-step SmartScrape interaction\nconst smartScrapeWrapperSchemaDefinition = {\n  type: \"object\",\n  properties: {\n    ...commonSmartScrapeProperties, // Include shared base properties\n    ...commonReasoningPromptProperties, // Include shared reasoning/prompt properties\n    // extractedData will be added dynamically\n  },\n  additionalProperties: false,\n  required: [\"extractedData\", \"shouldUseSmartscrape\"],\n};\n\n// Schema for multi-step SmartScrape interaction\nconst multiSmartScrapeWrapperSchemaDefinition = {\n  type: \"object\",\n  properties: {\n    ...commonSmartScrapeProperties, // Include shared base properties\n    smartScrapePages: {\n      type: \"array\",\n      description:\n        \"Make an entry for each page we want to run smart scrape on, no matter how many actions it should be one entry per page.\",\n      items: {\n        type: \"object\",\n        properties: {\n          page_index: {\n            // Specific to items within the array\n            type: \"number\",\n            description: \"The index of the page in the SmartScrape process.\",\n          },\n          ...commonReasoningPromptProperties, // Include shared reasoning/prompt properties here too\n        },\n        // required: [\"page_index\", \"smartscrape_reasoning\", \"smartscrape_prompt\"], // If needed per step\n        // additionalProperties: false,\n      },\n    },\n    // extractedData will be added dynamically\n  },\n  additionalProperties: false,\n  required: [\"extractedData\", \"shouldUseSmartscrape\"],\n};\n\n//TODO: go over and check\n// should add null to all types\n// type:string should be type:[\"string\",\"null\"]\nexport function makeSchemaNullable(schema: any): any {\n  if (typeof schema !== \"object\" || schema === null) {\n    return schema; // Base case: not an object/array or is null\n  }\n\n  if (Array.isArray(schema)) {\n    return schema.map(makeSchemaNullable); // Recurse for array items\n  }\n\n  // Process object properties\n  const newSchema: { [key: string]: any } = {};\n  let isObject = false; // Flag to track if this level is an object type\n\n  for (const key in schema) {\n    if (key === \"additionalProperties\") {\n      continue; // Skip existing additionalProperties, we'll set it later if needed\n    }\n\n    if (key === \"type\") {\n      const currentType = schema[key];\n      let finalType: string | string[];\n\n      if (typeof currentType === \"string\") {\n        if (currentType === \"object\") isObject = true;\n        finalType =\n          currentType === \"null\" ? currentType : [currentType, \"null\"];\n      } else if (Array.isArray(currentType)) {\n        if (currentType.includes(\"object\")) isObject = true;\n        finalType = currentType.includes(\"null\")\n          ? currentType\n          : [...currentType, \"null\"];\n      } else {\n        finalType = currentType; // Handle unexpected types?\n      }\n      newSchema[key] = finalType;\n    } else if (typeof schema[key] === \"object\" && schema[key] !== null) {\n      // Recurse for nested objects (properties, items, definitions, etc.)\n      newSchema[key] = makeSchemaNullable(schema[key]);\n      if (key === \"properties\") {\n        // Having a 'properties' key strongly implies an object type\n        isObject = true;\n      }\n    } else {\n      // Copy other properties directly (like required, description, etc.)\n      newSchema[key] = schema[key];\n    }\n  }\n\n  // **Crucial Fix:** If this schema represents an object type, add additionalProperties: false\n  if (isObject) {\n    // Ensure 'properties' exists if 'type' was 'object' but 'properties' wasn't defined\n    if (!newSchema.properties) {\n      newSchema.properties = {};\n    }\n    newSchema.additionalProperties = false;\n  }\n\n  return newSchema;\n}\n\n/**\n * Wraps the original schema with SmartScrape fields if an original schema exists.\n *\n * @param originalSchema The user-provided schema (JSON Schema object or Zod schema).\n * @param logger Winston logger instance.\n * @returns An object containing the schema to use for the LLM call and whether wrapping occurred.\n */\nexport function prepareSmartScrapeSchema(\n  originalSchema: any | z.ZodTypeAny | undefined,\n  logger: Logger,\n  isSingleUrl: boolean,\n) {\n  // Make the user's schema nullable *and* ensure nested objects have additionalProperties:false\n  const nullableAndStrictSchema = originalSchema;\n\n  let smartScrapeWrapScehma;\n  if (isSingleUrl) {\n    smartScrapeWrapScehma = smartScrapeWrapperSchemaDefinition;\n  } else {\n    smartScrapeWrapScehma = multiSmartScrapeWrapperSchemaDefinition;\n  }\n\n  const wrappedSchema = {\n    ...smartScrapeWrapScehma, // Uses the wrapper defined above\n    properties: {\n      extractedData: nullableAndStrictSchema, // Nest the modified original schema\n      ...smartScrapeWrapScehma.properties, // Add smartscrape fields\n    },\n    // required is inherited from smartScrapeWrapperSchemaDefinition\n    // additionalProperties:false is inherited from smartScrapeWrapperSchemaDefinition for the top level\n  };\n\n  logger.info(\"Wrapping original schema with SmartScrape fields.\", {\n    // Limit logging potentially large schemas\n    wrappedSchemaKeys: Object.keys(wrappedSchema.properties),\n  });\n  return { schemaToUse: wrappedSchema };\n}\n\n// Resolve all $defs references in the schema\nconst resolveRefs = (obj: any, defs: any): any => {\n  if (!obj || typeof obj !== 'object') return obj;\n\n  if (obj.$ref && typeof obj.$ref === 'string') {\n    // Handle $ref references\n    const refPath = obj.$ref.split('/');\n    if (refPath[0] === '#' && refPath[1] === '$defs') {\n      const defName = refPath[refPath.length - 1];\n      return resolveRefs({ ...defs[defName] }, defs);\n    }\n  }\n\n  // Handle arrays\n  if (Array.isArray(obj)) {\n    return obj.map(item => resolveRefs(item, defs));\n  }\n\n  // Handle objects\n  const resolved: any = {};\n  for (const [key, value] of Object.entries(obj)) {\n    if (key === '$defs') continue;\n    resolved[key] = resolveRefs(value, defs);\n  }\n  return resolved;\n};\n\nexport async function extractData({\n  extractOptions,\n  urls,\n  useAgent,\n  extractId,\n  sessionId,\n  scrapeId,\n}: {\n  extractOptions: GenerateCompletionsOptions;\n  urls: string[];\n  useAgent: boolean;\n  extractId?: string;\n  sessionId?: string;\n  scrapeId?: string;\n}): Promise<{\n  extractedDataArray: any[];\n  warning: any;\n  costLimitExceededTokenUsage: number | null;\n}> {\n  let schema = extractOptions.options.schema;\n  const logger = extractOptions.logger;\n  const isSingleUrl = urls.length === 1;\n  let costLimitExceededTokenUsage: number | null = null;\n  // TODO: remove the \"required\" fields here!! it breaks o3-mini\n\n  if (!schema && extractOptions.options.prompt) {\n    const genRes = await generateSchemaFromPrompt(extractOptions.options.prompt, logger, extractOptions.costTrackingOptions.costTracking);\n    schema = genRes.extract;\n  }\n\n  if (schema) {\n    const defs = schema.$defs || {};\n    schema = resolveRefs(schema, defs);\n    delete schema.$defs;\n    logger.info(\"Resolved schema refs\", {\n      schema,\n    });\n  }\n\n  const { schemaToUse } = prepareSmartScrapeSchema(schema, logger, isSingleUrl);\n  const extractOptionsNewSchema = {\n    ...extractOptions,\n    options: { ...extractOptions.options, schema: schemaToUse },\n  };\n  // console.log(\"schema\", schema);\n  // console.log(\"schemaToUse\", schemaToUse);\n  logger.info(\"Generated schema from prompt\", {\n    schemaToUse,\n  });\n\n  let extract: any,\n    warning: string | undefined,\n    totalUsage: TokenUsage | undefined;\n\n  // checks if using smartScrape is needed for this case\n  try {\n    const {\n      extract: e,\n      warning: w,\n      totalUsage: t,\n    } = await generateCompletions({\n      ...extractOptionsNewSchema,\n      costTrackingOptions: {\n        costTracking: extractOptions.costTrackingOptions.costTracking,\n        metadata: {\n          module: \"scrapeURL\",\n          method: \"extractData\",\n          description: \"Check if using smartScrape is needed for this case\"\n        },\n      },\n    });\n    extract = e;\n    warning = w;\n    totalUsage = t;\n  } catch (error) {\n    if (error instanceof CostLimitExceededError) {\n      throw error;\n    }\n    \n    logger.error(\n      \"failed during extractSmartScrape.ts:generateCompletions\",\n      { error },\n    );\n    // console.log(\"failed during extractSmartScrape.ts:generateCompletions\", error);\n  }\n\n  let extractedData = extract?.extractedData;\n\n  // console.log(\"shouldUseSmartscrape\", extract?.shouldUseSmartscrape);\n  // console.log(\"smartscrape_reasoning\", extract?.smartscrape_reasoning);\n  // console.log(\"smartscrape_prompt\", extract?.smartscrape_prompt);\n  try {\n    logger.info(\"Smart schema resolved\", {\n      useAgent,\n      shouldUseSmartscrape: extract?.shouldUseSmartscrape,\n      url: urls,\n      prompt: extract?.smartscrape_prompt,\n      providedExtractId: extractId,\n    })\n\n    if (useAgent && extract?.shouldUseSmartscrape) {\n      let smartscrapeResults: SmartScrapeResult[];\n      if (isSingleUrl) {\n        smartscrapeResults = [\n          await smartScrape({\n            url: urls[0],\n            prompt: extract?.smartscrape_prompt,\n            sessionId,\n            extractId,\n            scrapeId,\n            costTracking: extractOptions.costTrackingOptions.costTracking,\n          }),\n        ];\n      } else {\n        const pages = extract?.smartscrapePages ?? [];\n        //do it async promiseall instead\n        if (pages.length > 100) {\n          logger.warn(\"Smart scrape pages limit exceeded, only first 100 pages will be scraped\", {\n            pagesLength: pages.length,\n            extractId,\n            scrapeId,\n          });\n        }\n\n        smartscrapeResults = await Promise.all(\n          pages.slice(0, 100).map(async (page) => {\n            return await smartScrape({\n              url: urls[page.page_index],\n              prompt: page.smartscrape_prompt,\n              sessionId,\n              extractId,\n              scrapeId,\n              costTracking: extractOptions.costTrackingOptions.costTracking,\n            });\n          }),\n        );\n      }\n      // console.log(\"smartscrapeResults\", smartscrapeResults);\n\n      const scrapedPages = smartscrapeResults.map(\n        (result) => result.scrapedPages,\n      );\n      // console.log(\"scrapedPages\", scrapedPages);\n      const htmls = scrapedPages.flat().map((page) => page.html);\n      // console.log(\"htmls\", htmls);\n      const markdowns = await Promise.all(\n        htmls.map(async (html) => await parseMarkdown(html)),\n      );\n      // console.log(\"markdowns\", markdowns);\n      extractedData = await Promise.all(\n        markdowns.map(async (markdown) => {\n          const newExtractOptions = {\n            ...extractOptions,\n            markdown: markdown,\n            model: getModel(\"gemini-2.5-pro\", \"vertex\"),\n            retryModel: getModel(\"gemini-2.5-pro\", \"google\"),\n            costTrackingOptions: {\n              costTracking: extractOptions.costTrackingOptions.costTracking,\n              metadata: {\n                module: \"scrapeURL\",\n                method: \"extractData\",\n                description: \"Extract data from markdown (smart-scape results)\",\n              },\n            },\n          };\n          const { extract } =\n            await generateCompletions(newExtractOptions);\n          return extract;\n        }),\n      );\n\n      // console.log(\"markdowns\", markdowns);\n      // extractedData = smartscrapeResult;\n    } else {\n      extractedData = [extractedData];\n    }\n  } catch (error) {\n    console.error(\">>>>>>>extractSmartScrape.ts error>>>>>\\n\", error);\n    if (error instanceof Error && error.message === \"Cost limit exceeded\") {\n      costLimitExceededTokenUsage = (error as any).cause.tokenUsage;\n      warning = \"Smart scrape cost limit exceeded.\" + (warning ? \" \" + warning : \"\")\n    } else {\n      throw error;\n    }\n  }\n\n  return {\n    extractedDataArray: extractedData,\n    warning: warning,\n    costLimitExceededTokenUsage: costLimitExceededTokenUsage,\n  };\n}\n"]}