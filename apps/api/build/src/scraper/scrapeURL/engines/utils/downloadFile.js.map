{"version":3,"file":"downloadFile.js","sourceRoot":"","sources":["../../../../../../src/scraper/scrapeURL/engines/utils/downloadFile.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AASA,8CAgBC;AAED,oCAqCC;AAhED,gDAAwB;AACxB,4CAAoB;AACpB,qCAA4D;AAC5D,uCAA0C;AAC1C,mCAAkC;AAClC,+BAAkC;AAClC,+CAAiC;AACjC,2CAAmD;AAE5C,KAAK,UAAU,iBAAiB,CACrC,GAAW,EACX,IAAyB;IAKzB,MAAM,QAAQ,GAAG,MAAM,MAAM,CAAC,KAAK,CAAC,GAAG,EAAE;QACvC,GAAG,IAAI;QACP,QAAQ,EAAE,QAAQ;QAClB,UAAU,EAAE,MAAM,IAAA,gCAAoB,EAAC,GAAG,CAAC;KAC5C,CAAC,CAAC;IACH,OAAO;QACL,QAAQ;QACR,MAAM,EAAE,MAAM,CAAC,IAAI,CAAC,MAAM,QAAQ,CAAC,WAAW,EAAE,CAAC;KAClD,CAAC;AACJ,CAAC;AAEM,KAAK,UAAU,YAAY,CAChC,EAAU,EACV,GAAW,EACX,IAAyB;IAKzB,MAAM,YAAY,GAAG,cAAI,CAAC,IAAI,CAAC,YAAE,CAAC,MAAM,EAAE,EAAE,YAAY,EAAE,KAAK,IAAA,SAAI,GAAE,EAAE,CAAC,CAAC;IACzE,MAAM,aAAa,GAAG,IAAA,2BAAiB,EAAC,YAAY,CAAC,CAAC;IAEtD,4DAA4D;IAC5D,MAAM,QAAQ,GAAG,MAAM,MAAM,CAAC,KAAK,CAAC,GAAG,EAAE;QACvC,GAAG,IAAI;QACP,QAAQ,EAAE,QAAQ;QAClB,UAAU,EAAE,MAAM,IAAA,gCAAoB,EAAC,GAAG,CAAC;KAC5C,CAAC,CAAC;IAEH,8FAA8F;IAC9F,IAAI,QAAQ,CAAC,IAAI,KAAK,IAAI,EAAE,CAAC;QAC3B,MAAM,IAAI,mBAAW,CAAC,wBAAwB,EAAE,EAAE,KAAK,EAAE,EAAE,QAAQ,EAAE,EAAE,CAAC,CAAC;IAC3E,CAAC;IAED,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,iBAAQ,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC,CAAC;IACpD,MAAM,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;QACpC,aAAa,CAAC,EAAE,CAAC,QAAQ,EAAE,GAAG,EAAE,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC;QAChD,aAAa,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,KAAK,EAAE,EAAE;YAClC,MAAM,CACJ,IAAI,mBAAW,CAAC,8BAA8B,EAAE,EAAE,KAAK,EAAE,EAAE,KAAK,EAAE,EAAE,CAAC,CACtE,CAAC;QACJ,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IAEH,OAAO;QACL,QAAQ;QACR,YAAY;KACb,CAAC;AACJ,CAAC","sourcesContent":["import path from \"path\";\nimport os from \"os\";\nimport { createWriteStream, promises as fs } from \"node:fs\";\nimport { EngineError } from \"../../error\";\nimport { Writable } from \"stream\";\nimport { v4 as uuid } from \"uuid\";\nimport * as undici from \"undici\";\nimport { makeSecureDispatcher } from \"./safeFetch\";\n\nexport async function fetchFileToBuffer(\n  url: string,\n  init?: undici.RequestInit,\n): Promise<{\n  response: undici.Response;\n  buffer: Buffer;\n}> {\n  const response = await undici.fetch(url, {\n    ...init,\n    redirect: \"follow\",\n    dispatcher: await makeSecureDispatcher(url),\n  });\n  return {\n    response,\n    buffer: Buffer.from(await response.arrayBuffer()),\n  };\n}\n\nexport async function downloadFile(\n  id: string,\n  url: string,\n  init?: undici.RequestInit,\n): Promise<{\n  response: undici.Response;\n  tempFilePath: string;\n}> {\n  const tempFilePath = path.join(os.tmpdir(), `tempFile-${id}--${uuid()}`);\n  const tempFileWrite = createWriteStream(tempFilePath);\n\n  // TODO: maybe we could use tlsclient for this? for proxying\n  const response = await undici.fetch(url, {\n    ...init,\n    redirect: \"follow\",\n    dispatcher: await makeSecureDispatcher(url),\n  });\n\n  // This should never happen in the current state of JS/Undici (2024), but let's check anyways.\n  if (response.body === null) {\n    throw new EngineError(\"Response body was null\", { cause: { response } });\n  }\n\n  response.body.pipeTo(Writable.toWeb(tempFileWrite));\n  await new Promise((resolve, reject) => {\n    tempFileWrite.on(\"finish\", () => resolve(null));\n    tempFileWrite.on(\"error\", (error) => {\n      reject(\n        new EngineError(\"Failed to write to temp file\", { cause: { error } }),\n      );\n    });\n  });\n\n  return {\n    response,\n    tempFilePath,\n  };\n}\n"]}